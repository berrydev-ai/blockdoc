This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.github/
  workflows/
    tests.yml
assets/
  logo-dark.svg
  logo-full-dark.svg
  logo-full-light.svg
  logo-light.svg
  logo-wide-dark.svg
  logo-wide-light.svg
docs/
  api-docs/
    renderers/
      html.md
      markdown.md
    utils/
      sanitize.md
    block.md
    document.md
    README.md
  spec/
    blockdoc-specification.md
  tutorials/
    block-types.md
    getting-started.md
    llm-integration.md
examples/
  llm-integration/
    llm-integration-example.js
  react-demo/
    App.jsx
    BlockDocRenderer.jsx
  simple-blog/
    output/
      blog-post-updated.json
      blog-post.html
      blog-post.json
      blog-post.md
    index.js
  README.md
src/
  api/
    client.js
    server.js
  core/
    block.js
    document.js
  renderers/
    html.js
    markdown.js
  schema/
    blockdoc.schema.json
  utils/
    sanitize.js
  index.js
  schema-loader.js
tests/
  core/
    block.test.js
    document.test.js
  renderers/
    html.test.js
    markdown.test.js
  utils/
    sanitize.test.js
  integration.test.js
.babelrc
.eslintrc.json
.npmignore
babel.config.json
CLAUDE.md
CONTRIBUTING.md
index.d.ts
jest.config.js
LICENSE
NPM_PUBLICATION.md
package.json
README.md
rollup.config.cjs.js
rollup.config.esm.js
rollup.config.js
rollup.config.umd.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/tests.yml">
name: BlockDoc Tests

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [18.x, 20.x]

    steps:
    - uses: actions/checkout@v3
    
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Run tests
      run: npm test
      
    - name: Upload coverage reports
      uses: codecov/codecov-action@v3
      with:
        directory: ./coverage/
        fail_ci_if_error: false
</file>

<file path="assets/logo-dark.svg">
<svg width="151" height="131" viewBox="0 0 151 131" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_3_42)">
<path d="M75.0238 86.2456L76.0098 86.797L76.991 86.2372L148.5 45.4435V59.3451L75.9844 101.2L2 59.8269V45.4099L75.0238 86.2456ZM4.1162 42.0103L75.9903 2.29045L146.446 42.0103L75.9902 82.203L4.1162 42.0103Z" stroke="white" stroke-width="4"/>
<path d="M75.756 111.936L76.0024 112.074L76.2478 111.934L150 69.8609V87.2113L75.9961 129.925L0.5 87.7067V69.8525L75.756 111.936Z" fill="white" stroke="white"/>
<ellipse cx="75.5" cy="41" rx="9.5" ry="6" fill="white"/>
</g>
<defs>
<clipPath id="clip0_3_42">
<rect width="151" height="131" fill="white"/>
</clipPath>
</defs>
</svg>
</file>

<file path="assets/logo-full-dark.svg">
<svg width="452" height="283" viewBox="0 0 452 283" fill="none" xmlns="http://www.w3.org/2000/svg">
<g filter="url(#filter0_d_3_47)">
<path d="M55.6 192.656C62.064 192.656 67.568 195.12 72.112 200.048C76.72 204.912 79.024 210.896 79.024 218C79.024 225.104 76.72 231.12 72.112 236.048C67.568 240.912 62.064 243.344 55.6 243.344C48.88 243.344 43.696 241.008 40.048 236.336V242H27.664V174.8H40.048V199.664C43.696 194.992 48.88 192.656 55.6 192.656ZM43.792 227.792C46.288 230.288 49.456 231.536 53.296 231.536C57.136 231.536 60.304 230.288 62.8 227.792C65.36 225.232 66.64 221.968 66.64 218C66.64 214.032 65.36 210.8 62.8 208.304C60.304 205.744 57.136 204.464 53.296 204.464C49.456 204.464 46.288 205.744 43.792 208.304C41.296 210.8 40.048 214.032 40.048 218C40.048 221.968 41.296 225.232 43.792 227.792ZM87.7578 242V171.92H100.142V242H87.7578ZM152.373 236.048C147.445 240.912 141.429 243.344 134.325 243.344C127.221 243.344 121.205 240.912 116.277 236.048C111.413 231.12 108.98 225.104 108.98 218C108.98 210.896 111.413 204.912 116.277 200.048C121.205 195.12 127.221 192.656 134.325 192.656C141.429 192.656 147.445 195.12 152.373 200.048C157.301 204.912 159.765 210.896 159.765 218C159.765 225.104 157.301 231.12 152.373 236.048ZM125.013 227.504C127.509 230 130.613 231.248 134.325 231.248C138.037 231.248 141.141 230 143.637 227.504C146.133 225.008 147.381 221.84 147.381 218C147.381 214.16 146.133 210.992 143.637 208.496C141.141 206 138.037 204.752 134.325 204.752C130.613 204.752 127.509 206 125.013 208.496C122.581 210.992 121.365 214.16 121.365 218C121.365 221.84 122.581 225.008 125.013 227.504ZM191.325 243.344C184.093 243.344 178.045 240.912 173.181 236.048C168.381 231.184 165.98 225.168 165.98 218C165.98 210.832 168.381 204.816 173.181 199.952C178.045 195.088 184.093 192.656 191.325 192.656C195.997 192.656 200.253 193.776 204.093 196.016C207.933 198.256 210.845 201.264 212.829 205.04L202.173 211.28C201.213 209.296 199.741 207.728 197.757 206.576C195.837 205.424 193.661 204.848 191.229 204.848C187.517 204.848 184.445 206.096 182.013 208.592C179.581 211.024 178.365 214.16 178.365 218C178.365 221.776 179.581 224.912 182.013 227.408C184.445 229.84 187.517 231.056 191.229 231.056C193.725 231.056 195.933 230.512 197.853 229.424C199.837 228.272 201.309 226.704 202.269 224.72L213.021 230.864C210.909 234.64 207.933 237.68 204.093 239.984C200.253 242.224 195.997 243.344 191.325 243.344ZM263.826 242H249.426L231.954 220.208V242H219.57V174.8H231.954V215.12L248.466 194H263.25L243.954 217.712L263.826 242ZM302.923 174.8H315.307V242H302.923V236.336C299.275 241.008 294.091 243.344 287.371 243.344C280.907 243.344 275.371 240.912 270.763 236.048C266.219 231.12 263.947 225.104 263.947 218C263.947 210.896 266.219 204.912 270.763 200.048C275.371 195.12 280.907 192.656 287.371 192.656C294.091 192.656 299.275 194.992 302.923 199.664V174.8ZM280.075 227.792C282.635 230.288 285.835 231.536 289.675 231.536C293.515 231.536 296.683 230.288 299.179 227.792C301.675 225.232 302.923 221.968 302.923 218C302.923 214.032 301.675 210.8 299.179 208.304C296.683 205.744 293.515 204.464 289.675 204.464C285.835 204.464 282.635 205.744 280.075 208.304C277.579 210.8 276.331 214.032 276.331 218C276.331 221.968 277.579 225.232 280.075 227.792ZM367.529 236.048C362.601 240.912 356.585 243.344 349.481 243.344C342.377 243.344 336.361 240.912 331.433 236.048C326.569 231.12 324.137 225.104 324.137 218C324.137 210.896 326.569 204.912 331.433 200.048C336.361 195.12 342.377 192.656 349.481 192.656C356.585 192.656 362.601 195.12 367.529 200.048C372.457 204.912 374.921 210.896 374.921 218C374.921 225.104 372.457 231.12 367.529 236.048ZM340.169 227.504C342.665 230 345.769 231.248 349.481 231.248C353.193 231.248 356.297 230 358.793 227.504C361.289 225.008 362.537 221.84 362.537 218C362.537 214.16 361.289 210.992 358.793 208.496C356.297 206 353.193 204.752 349.481 204.752C345.769 204.752 342.665 206 340.169 208.496C337.737 210.992 336.521 214.16 336.521 218C336.521 221.84 337.737 225.008 340.169 227.504ZM406.481 243.344C399.249 243.344 393.201 240.912 388.337 236.048C383.537 231.184 381.137 225.168 381.137 218C381.137 210.832 383.537 204.816 388.337 199.952C393.201 195.088 399.249 192.656 406.481 192.656C411.153 192.656 415.409 193.776 419.249 196.016C423.089 198.256 426.001 201.264 427.985 205.04L417.329 211.28C416.369 209.296 414.897 207.728 412.913 206.576C410.993 205.424 408.817 204.848 406.385 204.848C402.673 204.848 399.601 206.096 397.169 208.592C394.737 211.024 393.521 214.16 393.521 218C393.521 221.776 394.737 224.912 397.169 227.408C399.601 229.84 402.673 231.056 406.385 231.056C408.881 231.056 411.089 230.512 413.009 229.424C414.993 228.272 416.465 226.704 417.425 224.72L428.177 230.864C426.065 234.64 423.089 237.68 419.249 239.984C415.409 242.224 411.153 243.344 406.481 243.344Z" fill="white"/>
<path d="M226.024 112.246L227.01 112.797L227.991 112.237L299.5 71.4435V85.3451L226.984 127.2L153 85.8269V71.4099L226.024 112.246ZM155.116 68.0103L226.99 28.2905L297.446 68.0103L226.99 108.203L155.116 68.0103Z" stroke="white" stroke-width="4"/>
<path d="M226.756 137.936L227.002 138.074L227.248 137.934L301 95.8609V113.211L226.996 155.925L151.5 113.707V95.8525L226.756 137.936Z" fill="white" stroke="white"/>
<ellipse cx="226.5" cy="67" rx="9.5" ry="6" fill="white"/>
</g>
<defs>
<filter id="filter0_d_3_47" x="0" y="0" width="452" height="283" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset dy="4"/>
<feGaussianBlur stdDeviation="2"/>
<feComposite in2="hardAlpha" operator="out"/>
<feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"/>
<feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_3_47"/>
<feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow_3_47" result="shape"/>
</filter>
</defs>
</svg>
</file>

<file path="assets/logo-full-light.svg">
<svg width="444" height="275" viewBox="0 0 444 275" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M51.6 192.656C58.064 192.656 63.568 195.12 68.112 200.048C72.72 204.912 75.024 210.896 75.024 218C75.024 225.104 72.72 231.12 68.112 236.048C63.568 240.912 58.064 243.344 51.6 243.344C44.88 243.344 39.696 241.008 36.048 236.336V242H23.664V174.8H36.048V199.664C39.696 194.992 44.88 192.656 51.6 192.656ZM39.792 227.792C42.288 230.288 45.456 231.536 49.296 231.536C53.136 231.536 56.304 230.288 58.8 227.792C61.36 225.232 62.64 221.968 62.64 218C62.64 214.032 61.36 210.8 58.8 208.304C56.304 205.744 53.136 204.464 49.296 204.464C45.456 204.464 42.288 205.744 39.792 208.304C37.296 210.8 36.048 214.032 36.048 218C36.048 221.968 37.296 225.232 39.792 227.792ZM83.7578 242V171.92H96.1418V242H83.7578ZM148.373 236.048C143.445 240.912 137.429 243.344 130.325 243.344C123.221 243.344 117.205 240.912 112.277 236.048C107.413 231.12 104.98 225.104 104.98 218C104.98 210.896 107.413 204.912 112.277 200.048C117.205 195.12 123.221 192.656 130.325 192.656C137.429 192.656 143.445 195.12 148.373 200.048C153.301 204.912 155.765 210.896 155.765 218C155.765 225.104 153.301 231.12 148.373 236.048ZM121.013 227.504C123.509 230 126.613 231.248 130.325 231.248C134.037 231.248 137.141 230 139.637 227.504C142.133 225.008 143.381 221.84 143.381 218C143.381 214.16 142.133 210.992 139.637 208.496C137.141 206 134.037 204.752 130.325 204.752C126.613 204.752 123.509 206 121.013 208.496C118.581 210.992 117.365 214.16 117.365 218C117.365 221.84 118.581 225.008 121.013 227.504ZM187.325 243.344C180.093 243.344 174.045 240.912 169.181 236.048C164.381 231.184 161.98 225.168 161.98 218C161.98 210.832 164.381 204.816 169.181 199.952C174.045 195.088 180.093 192.656 187.325 192.656C191.997 192.656 196.253 193.776 200.093 196.016C203.933 198.256 206.845 201.264 208.829 205.04L198.173 211.28C197.213 209.296 195.741 207.728 193.757 206.576C191.837 205.424 189.661 204.848 187.229 204.848C183.517 204.848 180.445 206.096 178.013 208.592C175.581 211.024 174.365 214.16 174.365 218C174.365 221.776 175.581 224.912 178.013 227.408C180.445 229.84 183.517 231.056 187.229 231.056C189.725 231.056 191.933 230.512 193.853 229.424C195.837 228.272 197.309 226.704 198.269 224.72L209.021 230.864C206.909 234.64 203.933 237.68 200.093 239.984C196.253 242.224 191.997 243.344 187.325 243.344ZM259.826 242H245.426L227.954 220.208V242H215.57V174.8H227.954V215.12L244.466 194H259.25L239.954 217.712L259.826 242ZM298.923 174.8H311.307V242H298.923V236.336C295.275 241.008 290.091 243.344 283.371 243.344C276.907 243.344 271.371 240.912 266.763 236.048C262.219 231.12 259.947 225.104 259.947 218C259.947 210.896 262.219 204.912 266.763 200.048C271.371 195.12 276.907 192.656 283.371 192.656C290.091 192.656 295.275 194.992 298.923 199.664V174.8ZM276.075 227.792C278.635 230.288 281.835 231.536 285.675 231.536C289.515 231.536 292.683 230.288 295.179 227.792C297.675 225.232 298.923 221.968 298.923 218C298.923 214.032 297.675 210.8 295.179 208.304C292.683 205.744 289.515 204.464 285.675 204.464C281.835 204.464 278.635 205.744 276.075 208.304C273.579 210.8 272.331 214.032 272.331 218C272.331 221.968 273.579 225.232 276.075 227.792ZM363.529 236.048C358.601 240.912 352.585 243.344 345.481 243.344C338.377 243.344 332.361 240.912 327.433 236.048C322.569 231.12 320.137 225.104 320.137 218C320.137 210.896 322.569 204.912 327.433 200.048C332.361 195.12 338.377 192.656 345.481 192.656C352.585 192.656 358.601 195.12 363.529 200.048C368.457 204.912 370.921 210.896 370.921 218C370.921 225.104 368.457 231.12 363.529 236.048ZM336.169 227.504C338.665 230 341.769 231.248 345.481 231.248C349.193 231.248 352.297 230 354.793 227.504C357.289 225.008 358.537 221.84 358.537 218C358.537 214.16 357.289 210.992 354.793 208.496C352.297 206 349.193 204.752 345.481 204.752C341.769 204.752 338.665 206 336.169 208.496C333.737 210.992 332.521 214.16 332.521 218C332.521 221.84 333.737 225.008 336.169 227.504ZM402.481 243.344C395.249 243.344 389.201 240.912 384.337 236.048C379.537 231.184 377.137 225.168 377.137 218C377.137 210.832 379.537 204.816 384.337 199.952C389.201 195.088 395.249 192.656 402.481 192.656C407.153 192.656 411.409 193.776 415.249 196.016C419.089 198.256 422.001 201.264 423.985 205.04L413.329 211.28C412.369 209.296 410.897 207.728 408.913 206.576C406.993 205.424 404.817 204.848 402.385 204.848C398.673 204.848 395.601 206.096 393.169 208.592C390.737 211.024 389.521 214.16 389.521 218C389.521 221.776 390.737 224.912 393.169 227.408C395.601 229.84 398.673 231.056 402.385 231.056C404.881 231.056 407.089 230.512 409.009 229.424C410.993 228.272 412.465 226.704 413.425 224.72L424.177 230.864C422.065 234.64 419.089 237.68 415.249 239.984C411.409 242.224 407.153 243.344 402.481 243.344Z" fill="black"/>
<path d="M222.024 112.246L223.01 112.797L223.991 112.237L295.5 71.4435V85.3451L222.984 127.2L149 85.8269V71.4099L222.024 112.246ZM151.116 68.0103L222.99 28.2905L293.446 68.0103L222.99 108.203L151.116 68.0103Z" fill="white" stroke="black" stroke-width="4"/>
<path d="M222.756 137.936L223.002 138.074L223.248 137.934L297 95.8609V113.211L222.996 155.925L147.5 113.707V95.8525L222.756 137.936Z" fill="black" stroke="black"/>
<ellipse cx="222.5" cy="67" rx="9.5" ry="6" fill="black"/>
</svg>
</file>

<file path="assets/logo-light.svg">
<svg width="151" height="131" viewBox="0 0 151 131" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_3_34)">
<path d="M75.0238 86.2456L76.0098 86.797L76.991 86.2372L148.5 45.4435V59.3451L75.9844 101.2L2 59.8269V45.4099L75.0238 86.2456ZM4.1162 42.0103L75.9903 2.29045L146.446 42.0103L75.9902 82.203L4.1162 42.0103Z" fill="white" stroke="black" stroke-width="4"/>
<path d="M75.756 111.936L76.0024 112.074L76.2478 111.934L150 69.8609V87.2113L75.9961 129.925L0.5 87.7067V69.8525L75.756 111.936Z" fill="black" stroke="black"/>
<ellipse cx="75.5" cy="41" rx="9.5" ry="6" fill="black"/>
</g>
<defs>
<clipPath id="clip0_3_34">
<rect width="151" height="131" fill="white"/>
</clipPath>
</defs>
</svg>
</file>

<file path="assets/logo-wide-dark.svg">
<svg width="572" height="127" viewBox="0 0 572 127" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_3_59)">
<path d="M197.6 36.656C204.064 36.656 209.568 39.12 214.112 44.048C218.72 48.912 221.024 54.896 221.024 62C221.024 69.104 218.72 75.12 214.112 80.048C209.568 84.912 204.064 87.344 197.6 87.344C190.88 87.344 185.696 85.008 182.048 80.336V86H169.664V18.8H182.048V43.664C185.696 38.992 190.88 36.656 197.6 36.656ZM185.792 71.792C188.288 74.288 191.456 75.536 195.296 75.536C199.136 75.536 202.304 74.288 204.8 71.792C207.36 69.232 208.64 65.968 208.64 62C208.64 58.032 207.36 54.8 204.8 52.304C202.304 49.744 199.136 48.464 195.296 48.464C191.456 48.464 188.288 49.744 185.792 52.304C183.296 54.8 182.048 58.032 182.048 62C182.048 65.968 183.296 69.232 185.792 71.792ZM229.758 86V15.92H242.142V86H229.758ZM294.373 80.048C289.445 84.912 283.429 87.344 276.325 87.344C269.221 87.344 263.205 84.912 258.277 80.048C253.413 75.12 250.98 69.104 250.98 62C250.98 54.896 253.413 48.912 258.277 44.048C263.205 39.12 269.221 36.656 276.325 36.656C283.429 36.656 289.445 39.12 294.373 44.048C299.301 48.912 301.765 54.896 301.765 62C301.765 69.104 299.301 75.12 294.373 80.048ZM267.013 71.504C269.509 74 272.613 75.248 276.325 75.248C280.037 75.248 283.141 74 285.637 71.504C288.133 69.008 289.381 65.84 289.381 62C289.381 58.16 288.133 54.992 285.637 52.496C283.141 50 280.037 48.752 276.325 48.752C272.613 48.752 269.509 50 267.013 52.496C264.581 54.992 263.365 58.16 263.365 62C263.365 65.84 264.581 69.008 267.013 71.504ZM333.325 87.344C326.093 87.344 320.045 84.912 315.181 80.048C310.381 75.184 307.98 69.168 307.98 62C307.98 54.832 310.381 48.816 315.181 43.952C320.045 39.088 326.093 36.656 333.325 36.656C337.997 36.656 342.253 37.776 346.093 40.016C349.933 42.256 352.845 45.264 354.829 49.04L344.173 55.28C343.213 53.296 341.741 51.728 339.757 50.576C337.837 49.424 335.661 48.848 333.229 48.848C329.517 48.848 326.445 50.096 324.013 52.592C321.581 55.024 320.365 58.16 320.365 62C320.365 65.776 321.581 68.912 324.013 71.408C326.445 73.84 329.517 75.056 333.229 75.056C335.725 75.056 337.933 74.512 339.853 73.424C341.837 72.272 343.309 70.704 344.269 68.72L355.021 74.864C352.909 78.64 349.933 81.68 346.093 83.984C342.253 86.224 337.997 87.344 333.325 87.344ZM405.826 86H391.426L373.954 64.208V86H361.57V18.8H373.954V59.12L390.466 38H405.25L385.954 61.712L405.826 86ZM444.923 18.8H457.307V86H444.923V80.336C441.275 85.008 436.091 87.344 429.371 87.344C422.907 87.344 417.371 84.912 412.763 80.048C408.219 75.12 405.947 69.104 405.947 62C405.947 54.896 408.219 48.912 412.763 44.048C417.371 39.12 422.907 36.656 429.371 36.656C436.091 36.656 441.275 38.992 444.923 43.664V18.8ZM422.075 71.792C424.635 74.288 427.835 75.536 431.675 75.536C435.515 75.536 438.683 74.288 441.179 71.792C443.675 69.232 444.923 65.968 444.923 62C444.923 58.032 443.675 54.8 441.179 52.304C438.683 49.744 435.515 48.464 431.675 48.464C427.835 48.464 424.635 49.744 422.075 52.304C419.579 54.8 418.331 58.032 418.331 62C418.331 65.968 419.579 69.232 422.075 71.792ZM509.529 80.048C504.601 84.912 498.585 87.344 491.481 87.344C484.377 87.344 478.361 84.912 473.433 80.048C468.569 75.12 466.137 69.104 466.137 62C466.137 54.896 468.569 48.912 473.433 44.048C478.361 39.12 484.377 36.656 491.481 36.656C498.585 36.656 504.601 39.12 509.529 44.048C514.457 48.912 516.921 54.896 516.921 62C516.921 69.104 514.457 75.12 509.529 80.048ZM482.169 71.504C484.665 74 487.769 75.248 491.481 75.248C495.193 75.248 498.297 74 500.793 71.504C503.289 69.008 504.537 65.84 504.537 62C504.537 58.16 503.289 54.992 500.793 52.496C498.297 50 495.193 48.752 491.481 48.752C487.769 48.752 484.665 50 482.169 52.496C479.737 54.992 478.521 58.16 478.521 62C478.521 65.84 479.737 69.008 482.169 71.504ZM548.481 87.344C541.249 87.344 535.201 84.912 530.337 80.048C525.537 75.184 523.137 69.168 523.137 62C523.137 54.832 525.537 48.816 530.337 43.952C535.201 39.088 541.249 36.656 548.481 36.656C553.153 36.656 557.409 37.776 561.249 40.016C565.089 42.256 568.001 45.264 569.985 49.04L559.329 55.28C558.369 53.296 556.897 51.728 554.913 50.576C552.993 49.424 550.817 48.848 548.385 48.848C544.673 48.848 541.601 50.096 539.169 52.592C536.737 55.024 535.521 58.16 535.521 62C535.521 65.776 536.737 68.912 539.169 71.408C541.601 73.84 544.673 75.056 548.385 75.056C550.881 75.056 553.089 74.512 555.009 73.424C556.993 72.272 558.465 70.704 559.425 68.72L570.177 74.864C568.065 78.64 565.089 81.68 561.249 83.984C557.409 86.224 553.153 87.344 548.481 87.344Z" fill="white"/>
<path d="M72.9855 83.9793L73.9715 84.5307L74.9527 83.9709L144.464 44.3171V57.7225L73.9461 98.4239L2 58.1909V44.2835L72.9855 83.9793ZM4.1162 40.8839L73.952 2.29045L142.409 40.8839L73.9519 79.9368L4.1162 40.8839Z" stroke="white" stroke-width="4"/>
<path d="M73.7176 108.946L73.9641 109.084L74.2094 108.944L145.964 68.0103V84.8645L73.9578 126.425L0.5 85.3466V68.0019L73.7176 108.946Z" fill="white" stroke="white"/>
<path d="M82.2203 39.9004C82.2203 41.2807 81.3333 42.6036 79.7455 43.6065C78.164 44.6053 75.9484 45.2395 73.4751 45.2395C71.0018 45.2395 68.7862 44.6053 67.2047 43.6065C65.6169 42.6036 64.7299 41.2807 64.7299 39.9004C64.7299 38.52 65.6169 37.1971 67.2047 36.1943C68.7862 35.1955 71.0018 34.5613 73.4751 34.5613C75.9484 34.5613 78.164 35.1955 79.7455 36.1943C81.3333 37.1971 82.2203 38.52 82.2203 39.9004Z" fill="white" stroke="white"/>
</g>
<defs>
<clipPath id="clip0_3_59">
<rect width="572" height="127" fill="white"/>
</clipPath>
</defs>
</svg>
</file>

<file path="assets/logo-wide-light.svg">
<svg width="572" height="127" viewBox="0 0 572 127" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_3_53)">
<path d="M197.6 36.656C204.064 36.656 209.568 39.12 214.112 44.048C218.72 48.912 221.024 54.896 221.024 62C221.024 69.104 218.72 75.12 214.112 80.048C209.568 84.912 204.064 87.344 197.6 87.344C190.88 87.344 185.696 85.008 182.048 80.336V86H169.664V18.8H182.048V43.664C185.696 38.992 190.88 36.656 197.6 36.656ZM185.792 71.792C188.288 74.288 191.456 75.536 195.296 75.536C199.136 75.536 202.304 74.288 204.8 71.792C207.36 69.232 208.64 65.968 208.64 62C208.64 58.032 207.36 54.8 204.8 52.304C202.304 49.744 199.136 48.464 195.296 48.464C191.456 48.464 188.288 49.744 185.792 52.304C183.296 54.8 182.048 58.032 182.048 62C182.048 65.968 183.296 69.232 185.792 71.792ZM229.758 86V15.92H242.142V86H229.758ZM294.373 80.048C289.445 84.912 283.429 87.344 276.325 87.344C269.221 87.344 263.205 84.912 258.277 80.048C253.413 75.12 250.98 69.104 250.98 62C250.98 54.896 253.413 48.912 258.277 44.048C263.205 39.12 269.221 36.656 276.325 36.656C283.429 36.656 289.445 39.12 294.373 44.048C299.301 48.912 301.765 54.896 301.765 62C301.765 69.104 299.301 75.12 294.373 80.048ZM267.013 71.504C269.509 74 272.613 75.248 276.325 75.248C280.037 75.248 283.141 74 285.637 71.504C288.133 69.008 289.381 65.84 289.381 62C289.381 58.16 288.133 54.992 285.637 52.496C283.141 50 280.037 48.752 276.325 48.752C272.613 48.752 269.509 50 267.013 52.496C264.581 54.992 263.365 58.16 263.365 62C263.365 65.84 264.581 69.008 267.013 71.504ZM333.325 87.344C326.093 87.344 320.045 84.912 315.181 80.048C310.381 75.184 307.98 69.168 307.98 62C307.98 54.832 310.381 48.816 315.181 43.952C320.045 39.088 326.093 36.656 333.325 36.656C337.997 36.656 342.253 37.776 346.093 40.016C349.933 42.256 352.845 45.264 354.829 49.04L344.173 55.28C343.213 53.296 341.741 51.728 339.757 50.576C337.837 49.424 335.661 48.848 333.229 48.848C329.517 48.848 326.445 50.096 324.013 52.592C321.581 55.024 320.365 58.16 320.365 62C320.365 65.776 321.581 68.912 324.013 71.408C326.445 73.84 329.517 75.056 333.229 75.056C335.725 75.056 337.933 74.512 339.853 73.424C341.837 72.272 343.309 70.704 344.269 68.72L355.021 74.864C352.909 78.64 349.933 81.68 346.093 83.984C342.253 86.224 337.997 87.344 333.325 87.344ZM405.826 86H391.426L373.954 64.208V86H361.57V18.8H373.954V59.12L390.466 38H405.25L385.954 61.712L405.826 86ZM444.923 18.8H457.307V86H444.923V80.336C441.275 85.008 436.091 87.344 429.371 87.344C422.907 87.344 417.371 84.912 412.763 80.048C408.219 75.12 405.947 69.104 405.947 62C405.947 54.896 408.219 48.912 412.763 44.048C417.371 39.12 422.907 36.656 429.371 36.656C436.091 36.656 441.275 38.992 444.923 43.664V18.8ZM422.075 71.792C424.635 74.288 427.835 75.536 431.675 75.536C435.515 75.536 438.683 74.288 441.179 71.792C443.675 69.232 444.923 65.968 444.923 62C444.923 58.032 443.675 54.8 441.179 52.304C438.683 49.744 435.515 48.464 431.675 48.464C427.835 48.464 424.635 49.744 422.075 52.304C419.579 54.8 418.331 58.032 418.331 62C418.331 65.968 419.579 69.232 422.075 71.792ZM509.529 80.048C504.601 84.912 498.585 87.344 491.481 87.344C484.377 87.344 478.361 84.912 473.433 80.048C468.569 75.12 466.137 69.104 466.137 62C466.137 54.896 468.569 48.912 473.433 44.048C478.361 39.12 484.377 36.656 491.481 36.656C498.585 36.656 504.601 39.12 509.529 44.048C514.457 48.912 516.921 54.896 516.921 62C516.921 69.104 514.457 75.12 509.529 80.048ZM482.169 71.504C484.665 74 487.769 75.248 491.481 75.248C495.193 75.248 498.297 74 500.793 71.504C503.289 69.008 504.537 65.84 504.537 62C504.537 58.16 503.289 54.992 500.793 52.496C498.297 50 495.193 48.752 491.481 48.752C487.769 48.752 484.665 50 482.169 52.496C479.737 54.992 478.521 58.16 478.521 62C478.521 65.84 479.737 69.008 482.169 71.504ZM548.481 87.344C541.249 87.344 535.201 84.912 530.337 80.048C525.537 75.184 523.137 69.168 523.137 62C523.137 54.832 525.537 48.816 530.337 43.952C535.201 39.088 541.249 36.656 548.481 36.656C553.153 36.656 557.409 37.776 561.249 40.016C565.089 42.256 568.001 45.264 569.985 49.04L559.329 55.28C558.369 53.296 556.897 51.728 554.913 50.576C552.993 49.424 550.817 48.848 548.385 48.848C544.673 48.848 541.601 50.096 539.169 52.592C536.737 55.024 535.521 58.16 535.521 62C535.521 65.776 536.737 68.912 539.169 71.408C541.601 73.84 544.673 75.056 548.385 75.056C550.881 75.056 553.089 74.512 555.009 73.424C556.993 72.272 558.465 70.704 559.425 68.72L570.177 74.864C568.065 78.64 565.089 81.68 561.249 83.984C557.409 86.224 553.153 87.344 548.481 87.344Z" fill="black"/>
<path d="M72.9855 83.9793L73.9715 84.5307L74.9527 83.9709L144.464 44.3171V57.7225L73.9461 98.4239L2 58.1909V44.2835L72.9855 83.9793ZM4.1162 40.8839L73.952 2.29045L142.409 40.8839L73.9519 79.9368L4.1162 40.8839Z" fill="white" stroke="black" stroke-width="4"/>
<path d="M73.7176 108.946L73.9641 109.084L74.2094 108.944L145.964 68.0103V84.8645L73.9578 126.425L0.5 85.3466V68.0019L73.7176 108.946Z" fill="black" stroke="black"/>
<ellipse cx="73.4751" cy="39.9004" rx="9.24521" ry="5.83908" fill="black"/>
</g>
<defs>
<clipPath id="clip0_3_53">
<rect width="572" height="127" fill="white"/>
</clipPath>
</defs>
</svg>
</file>

<file path="docs/api-docs/renderers/html.md">
# HTML Renderer API

The HTML renderer converts BlockDoc documents to HTML, with support for all block types and appropriate styling.

## Import

```javascript
import { renderToHTML } from 'blockdoc/renderers/html';
```

Or use through the BlockDocDocument class:

```javascript
const html = document.renderToHTML();
```

## Functions

### renderToHTML(article)

Render a BlockDoc document to HTML.

#### Parameters

- `article` (Object): The article object from a BlockDoc document

#### Returns

- (string): HTML representation

#### Throws

- `Error`: If invalid article structure

#### Example

```javascript
import { renderToHTML } from 'blockdoc/renderers/html';

const html = renderToHTML({
  title: 'My Document',
  blocks: [
    {
      id: 'intro',
      type: 'text',
      content: 'This is my document.'
    }
  ]
});
```

## HTML Output Structure

The HTML renderer generates semantic HTML that maintains the structure of your BlockDoc document.

### Document Structure

```html
<article class="blockdoc-article">
  <h1 class="blockdoc-title">Document Title</h1>
  <!-- Blocks go here -->
</article>
```

### Block Wrapper

Each block is wrapped in a div with appropriate classes and data attributes:

```html
<div class="blockdoc-block blockdoc-[type]" data-block-id="[id]" data-block-type="[type]">
  <!-- Block content -->
</div>
```

### Block Type Rendering

#### Text Block

Text blocks are rendered as HTML paragraphs, with Markdown converted to HTML:

```html
<p>This is <strong>bold</strong> and <em>italic</em> text.</p>
```

#### Heading Block

```html
<h2>Section Heading</h2>
```

#### Image Block

```html
<figure class="blockdoc-figure">
  <img src="image-url.jpg" alt="Image description" class="blockdoc-image" />
  <figcaption class="blockdoc-caption">Image caption</figcaption>
</figure>
```

#### Code Block

Code blocks include syntax highlighting via highlight.js:

```html
<pre class="blockdoc-pre">
  <code class="blockdoc-code language-javascript">function example() {
  console.log("Hello");
}</code>
</pre>
```

#### List Block

```html
<ul class="blockdoc-list blockdoc-list-unordered">
  <li>Item one</li>
  <li>Item two</li>
</ul>
```

#### Quote Block

```html
<blockquote class="blockdoc-quote">
  <p>Quote text</p>
</blockquote>
<cite class="blockdoc-attribution">Attribution</cite>
```

#### Embed Block

Embed blocks have special handling for common embed types like YouTube:

```html
<div class="blockdoc-embed-container">
  <iframe 
    width="560" 
    height="315" 
    src="https://www.youtube.com/embed/videoId" 
    frameborder="0" 
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
    allowfullscreen>
  </iframe>
</div>
```

#### Divider Block

```html
<hr class="blockdoc-divider" />
```

## CSS Classes

The HTML renderer adds CSS classes to all elements for styling:

- `blockdoc-article`: Wrapper for the entire document
- `blockdoc-title`: Document title
- `blockdoc-block`: Wrapper for each block
- `blockdoc-[type]`: Class specific to the block type
- `blockdoc-image`: Image element
- `blockdoc-figure`: Figure wrapper for images with captions
- `blockdoc-caption`: Caption for images or embeds
- `blockdoc-pre`: Pre element for code blocks
- `blockdoc-code`: Code element for code blocks
- `blockdoc-list`: List element
- `blockdoc-list-[type]`: Class for list type (ordered/unordered)
- `blockdoc-quote`: Blockquote element
- `blockdoc-attribution`: Citation for quotes
- `blockdoc-embed`: Wrapper for embedded content
- `blockdoc-divider`: Horizontal rule

## Security

The HTML renderer uses the `sanitizeHtml` function to prevent XSS attacks by escaping HTML special characters in content. Additionally, URLs are validated to ensure they use safe protocols.
</file>

<file path="docs/api-docs/renderers/markdown.md">
# Markdown Renderer API

The Markdown renderer converts BlockDoc documents to Markdown text, preserving the structure and formatting of the original document.

## Import

```javascript
import { renderToMarkdown } from 'blockdoc/renderers/markdown';
```

Or use through the BlockDocDocument class:

```javascript
const markdown = document.renderToMarkdown();
```

## Functions

### renderToMarkdown(article)

Render a BlockDoc document to Markdown.

#### Parameters

- `article` (Object): The article object from a BlockDoc document

#### Returns

- (string): Markdown representation

#### Throws

- `Error`: If invalid article structure

#### Example

```javascript
import { renderToMarkdown } from 'blockdoc/renderers/markdown';

const markdown = renderToMarkdown({
  title: 'My Document',
  blocks: [
    {
      id: 'intro',
      type: 'text',
      content: 'This is my document.'
    }
  ]
});
```

## Markdown Output Format

The Markdown renderer generates Markdown that maintains the structure and formatting of your BlockDoc document.

### Document Structure

```markdown
# Document Title

> Author: Document Author
> Published: Publication Date
> Tags: tag1, tag2, tag3

...
```

### Block Type Rendering

#### Text Block

Text blocks are rendered directly, as they already use Markdown formatting:

```markdown
This is **bold** and *italic* text.
```

#### Heading Block

```markdown
## Section Heading
```

#### Image Block

```markdown
![Image description](image-url.jpg)
*Image caption*
```

#### Code Block

```markdown
```javascript
function example() {
  console.log("Hello");
}
```
```

#### List Block

Ordered list:
```markdown
1. Item one
2. Item two
```

Unordered list:
```markdown
- Item one
- Item two
```

#### Quote Block

```markdown
> Quote text
>
>  Attribution
```

#### Embed Block

```markdown
[Embedded content: https://example.com](https://example.com)
*Caption text*
```

#### Divider Block

```markdown
---
```

## Metadata Handling

The Markdown renderer includes document metadata in the output:

- Author is included as `> Author: [name]`
- Publication date is formatted as `> Published: [date]`
- Tags are listed as `> Tags: tag1, tag2, tag3`

This ensures that the metadata is preserved in a human-readable format when exporting to Markdown.
</file>

<file path="docs/api-docs/utils/sanitize.md">
# HTML Sanitization Utilities

The sanitization utilities provide functions for safely handling HTML content and URLs to prevent security vulnerabilities like XSS attacks.

## Import

```javascript
import { sanitizeHtml, sanitizeUrl } from 'blockdoc/utils/sanitize';
```

## Functions

### sanitizeHtml(html)

Simple HTML sanitizer to prevent XSS by escaping HTML special characters.

#### Parameters

- `html` (string): HTML content to sanitize

#### Returns

- (string): Sanitized HTML with special characters escaped

#### Example

```javascript
import { sanitizeHtml } from 'blockdoc/utils/sanitize';

const userInput = '<script>alert("XSS");</script>';
const safe = sanitizeHtml(userInput);
// Results in: '&lt;script&gt;alert(&quot;XSS&quot;);&lt;/script&gt;'
```

### sanitizeUrl(url)

Sanitize a URL to ensure it uses safe protocols.

#### Parameters

- `url` (string): URL to sanitize

#### Returns

- (string): Sanitized URL or empty string if unsafe

#### Example

```javascript
import { sanitizeUrl } from 'blockdoc/utils/sanitize';

// Safe URL - returns the URL unchanged
sanitizeUrl('https://example.com/image.jpg');

// Protocol-relative URL - adds https:
sanitizeUrl('//example.com/image.jpg');
// Results in: 'https://example.com/image.jpg'

// Unsafe URL - returns empty string
sanitizeUrl('javascript:alert("XSS");');
// Results in: ''
```

## Security Considerations

### XSS Prevention

The `sanitizeHtml` function prevents Cross-Site Scripting (XSS) attacks by escaping the following characters:

- `&` → `&amp;`
- `<` → `&lt;`
- `>` → `&gt;`
- `"` → `&quot;`
- `'` → `&#039;`

This ensures that any HTML or JavaScript in user-provided content is rendered as text rather than being executed.

### URL Sanitization

The `sanitizeUrl` function prevents JavaScript injection through URLs by:

1. Only allowing HTTP and HTTPS protocols
2. Converting protocol-relative URLs (`//example.com`) to HTTPS
3. Allowing relative URLs that don't include a protocol
4. Returning an empty string for potentially unsafe protocols

## Usage in BlockDoc

These utilities are used internally by the HTML renderer to ensure that content is safely rendered. You can also use them directly when working with user-provided content that will be displayed in HTML contexts.
</file>

<file path="docs/api-docs/block.md">
# Block Class API

The `Block` class represents a single content block within a BlockDoc document. Each block has a unique ID, a type, content, and optional additional properties depending on the block type.

## Import

```javascript
import { Block } from 'blockdoc';
```

## Constructor

```javascript
new Block(data)
```

Creates a new Block instance.

### Parameters

- `data` (Object): Block data with the following properties:
  - `id` (string, required): Unique identifier for the block
  - `type` (string, required): Block type (must be one of the allowed types)
  - `content` (string): Primary content of the block
  - Additional type-specific properties (see below)

### Throws

- `Error`: If required properties are missing or invalid

### Example

```javascript
const textBlock = new Block({
  id: 'intro',
  type: 'text',
  content: 'This is **important** text.'
});

const headingBlock = new Block({
  id: 'section-1',
  type: 'heading',
  level: 2,
  content: 'Section Title'
});
```

## Block Types

The following block types are supported:

| Type | Description | Required Properties | Optional Properties |
|------|-------------|---------------------|--------------------|
| `text` | Text paragraph with Markdown | none | none |
| `heading` | Section heading | `level` (1-6) | none |
| `image` | Image | `url`, `alt` | `caption` |
| `code` | Code block | `language` | none |
| `list` | List of items | `items`, `listType` | none |
| `quote` | Blockquote | none | `attribution` |
| `embed` | Embedded content | none | `embedType`, `caption` |
| `divider` | Horizontal rule | none | none |

## Methods

### update(updates)

Update block properties.

#### Parameters

- `updates` (Object): Properties to update

#### Returns

- (Block): The updated block instance

#### Example

```javascript
const block = new Block({
  id: 'intro',
  type: 'text',
  content: 'Original content'
});

block.update({ content: 'Updated content' });
```

### toJSON()

Convert block to a plain object.

#### Returns

- (Object): Block as a plain object

#### Example

```javascript
const block = new Block({
  id: 'intro',
  type: 'text',
  content: 'Some content'
});

const json = block.toJSON();
// { id: 'intro', type: 'text', content: 'Some content' }
```

## Static Factory Methods

The Block class provides static factory methods for creating common block types with a simplified API.

### Block.text(id, content)

Create a text block.

#### Parameters

- `id` (string): Block ID
- `content` (string): Markdown content

#### Returns

- (Block): New text block instance

#### Example

```javascript
const block = Block.text('intro', 'This is **bold** text.');
```

### Block.heading(id, level, content)

Create a heading block.

#### Parameters

- `id` (string): Block ID
- `level` (number): Heading level (1-6)
- `content` (string): Heading text

#### Returns

- (Block): New heading block instance

#### Example

```javascript
const block = Block.heading('section-1', 2, 'Section Title');
```

### Block.image(id, url, alt, caption)

Create an image block.

#### Parameters

- `id` (string): Block ID
- `url` (string): Image URL
- `alt` (string): Alt text
- `caption` (string, optional): Image caption

#### Returns

- (Block): New image block instance

#### Example

```javascript
const block = Block.image(
  'hero-image',
  'https://example.com/image.jpg',
  'Example image',
  'Figure 1: Example caption'
);
```

### Block.code(id, language, content)

Create a code block.

#### Parameters

- `id` (string): Block ID
- `language` (string): Programming language
- `content` (string): Code content

#### Returns

- (Block): New code block instance

#### Example

```javascript
const block = Block.code(
  'example-code',
  'javascript',
  'function hello() {\n  console.log("Hello world");\n}'
);
```

### Block.list(id, items, listType)

Create a list block.

#### Parameters

- `id` (string): Block ID
- `items` (Array<string>): List items
- `listType` (string, optional): List type ('ordered' or 'unordered', defaults to 'unordered')

#### Returns

- (Block): New list block instance

#### Example

```javascript
const block = Block.list(
  'key-points',
  ['First item', 'Second item', 'Third item'],
  'unordered'
);
```
</file>

<file path="docs/api-docs/document.md">
# BlockDocDocument Class API

The `BlockDocDocument` class is the main entry point for creating and manipulating BlockDoc documents. It provides methods for adding, updating, and removing blocks, as well as rendering the document to different formats.

## Import

```javascript
import { BlockDocDocument } from "blockdoc"
```

## Constructor

```javascript
new BlockDocDocument(options)
```

Creates a new BlockDocDocument instance.

### Parameters

- `options` (Object): Document initialization options
  - `title` (string, required): Document title
  - `metadata` (Object, optional): Optional document metadata
  - `blocks` (Array<Object>, optional): Initial blocks to add

### Example

```javascript
const doc = new BlockDocDocument({
  title: "My First Document",
  metadata: {
    author: "John Doe",
    publishedDate: "2025-03-23T12:00:00Z",
    tags: ["example", "blockdoc"],
  },
  blocks: [
    {
      id: "intro",
      type: "text",
      content: "This is my first BlockDoc document.",
    },
  ],
})
```

## Properties

### article

The article object containing the document's title, metadata, and blocks.

```javascript
doc.article.title // Document title
doc.article.metadata // Document metadata
doc.article.blocks // Array of blocks
```

## Methods

### validate()

Validate the document against the BlockDoc schema.

#### Returns

- (boolean): True if valid

#### Throws

- `Error`: If validation fails

#### Example

```javascript
try {
  doc.validate()
  console.log("Document is valid")
} catch (error) {
  console.error("Validation failed:", error.message)
}
```

### addBlock(blockData)

Add a block to the document.

#### Parameters

- `blockData` (Object): Block data (see Block constructor)

#### Returns

- (Block): The created block

#### Throws

- `Error`: If a block with the same ID already exists

#### Example

```javascript
const block = doc.addBlock({
  id: "section-1",
  type: "heading",
  level: 2,
  content: "Section Title",
})

// Using factory methods
doc.addBlock(Block.text("paragraph-1", "This is a paragraph."))
```

### insertBlock(blockData, position)

Insert a block at a specific position.

#### Parameters

- `blockData` (Object): Block data
- `position` (number): Position to insert at (0-based index)

#### Returns

- (Block): The created block

#### Throws

- `Error`: If a block with the same ID already exists

#### Example

```javascript
const block = doc.insertBlock(
  {
    id: "new-intro",
    type: "text",
    content: "This comes before everything else.",
  },
  0
)
```

### getBlock(id)

Get a block by ID.

#### Parameters

- `id` (string): Block ID

#### Returns

- (Object|null): The block or null if not found

#### Example

```javascript
const block = doc.getBlock("intro")

if (block) {
  console.log(block.content)
}
```

### updateBlock(id, updates)

Update a block by ID.

#### Parameters

- `id` (string): Block ID
- `updates` (Object): Properties to update

#### Returns

- (Object): The updated block

#### Throws

- `Error`: If block with given ID not found

#### Example

```javascript
const updated = doc.updateBlock("intro", {
  content: "This is the updated introduction.",
})
```

### removeBlock(id)

Remove a block by ID.

#### Parameters

- `id` (string): Block ID

#### Returns

- (boolean): True if removed, false if not found

#### Example

```javascript
const removed = doc.removeBlock("unnecessary-section")

if (removed) {
  console.log("Block removed successfully")
}
```

### moveBlock(id, newPosition)

Move a block to a new position.

#### Parameters

- `id` (string): Block ID
- `newPosition` (number): New position (0-based index)

#### Returns

- (boolean): True if moved, false if not found

#### Throws

- `Error`: If invalid position

#### Example

```javascript
const moved = doc.moveBlock("conclusion", 5)

if (moved) {
  console.log("Block moved successfully")
}
```

### renderToHTML()

Render the document to HTML.

#### Returns

- (string): HTML representation

#### Example

```javascript
const html = doc.renderToHTML()

// Use in browser
document.getElementById("content").innerHTML = html

// Or write to file
import fs from "fs/promises"
await fs.writeFile("output.html", html, "utf8")
```

### renderToMarkdown()

Render the document to Markdown.

#### Returns

- (string): Markdown representation

#### Example

```javascript
const markdown = doc.renderToMarkdown()

// Write to file
import fs from "fs/promises"
await fs.writeFile("output.md", markdown, "utf8")
```

### toJSON()

Export the document as a JSON object.

#### Returns

- (Object): Document as JSON object

#### Example

```javascript
const json = doc.toJSON()
// { article: { title: '...', metadata: {...}, blocks: [...] } }
```

### toString()

Export the document as a JSON string.

#### Returns

- (string): Document as JSON string

#### Example

```javascript
const jsonString = doc.toString()

// Write to file
import fs from "fs/promises"
await fs.writeFile("document.json", jsonString, "utf8")
```

## Static Methods

### BlockDocDocument.fromJSON(json)

Create a BlockDoc document from a JSON object or string.

#### Parameters

- `json` (Object|string): JSON object or string

#### Returns

- (BlockDocDocument): New document instance

#### Throws

- `Error`: If invalid JSON or missing required properties

#### Example

```javascript
// From object
const doc1 = BlockDocDocument.fromJSON({
  article: {
    title: 'My Document',
    blocks: [...]
  }
});

// From string
const json = await fs.readFile('document.json', 'utf8');
const doc2 = BlockDocDocument.fromJSON(json);
```
</file>

<file path="docs/api-docs/README.md">
# BlockDoc API Reference

BlockDoc provides a simple yet powerful API for creating, manipulating, and rendering structured content. This reference documentation covers all the public APIs available in the BlockDoc library.

## Table of Contents

- [Core Components](#core-components)
  - [Block](#block)
  - [BlockDocDocument](#blockdocdocument)
- [Renderers](#renderers)
  - [HTML Renderer](#html-renderer)
  - [Markdown Renderer](#markdown-renderer)
- [Utilities](#utilities)
  - [HTML Sanitization](#html-sanitization)

## Core Components

### Block

The `Block` class represents a single content unit within a BlockDoc document. It provides methods for creating and manipulating different types of content blocks.

[Read full Block documentation](./block.md)

### BlockDocDocument

The `BlockDocDocument` class is the main entry point for creating and manipulating BlockDoc documents. It provides methods for adding, updating, and removing blocks, as well as rendering the document to different formats.

[Read full BlockDocDocument documentation](./document.md)

## Renderers

BlockDoc includes built-in renderers for converting documents to different output formats.

### HTML Renderer

The HTML renderer converts BlockDoc documents to HTML, with support for all block types and appropriate styling.

[Read full HTML Renderer documentation](./renderers/html.md)

### Markdown Renderer

The Markdown renderer converts BlockDoc documents to Markdown text, preserving the structure and formatting of the original document.

[Read full Markdown Renderer documentation](./renderers/markdown.md)

## Utilities

BlockDoc includes various utility functions for common tasks.

### HTML Sanitization

Utilities for sanitizing HTML content and URLs to prevent XSS attacks and ensure security.

[Read full Sanitization utilities documentation](./utils/sanitize.md)
</file>

<file path="docs/tutorials/block-types.md">
# Working with Block Types in BlockDoc

This tutorial explores the different block types available in BlockDoc and how to use them effectively.

## Understanding Block Structure

Every block in BlockDoc has a common structure:

```javascript
{
  "id": "unique-semantic-id",
  "type": "block-type",
  // Type-specific properties go here
}
```

The `id` should be a meaningful identifier for the block that describes its content or purpose, not just a random ID. This makes content more maintainable and easier to update.

## Heading Blocks

Heading blocks represent section titles at different levels.

```javascript
import { Block } from 'blockdoc';

const headingBlock = Block.createHeading({
  id: "introduction-heading",
  content: "Introduction to BlockDoc",
  level: 1 // h1, h2, h3, etc. (1-6)
});
```

### Rendering Considerations
- HTML: Renders as `<h1>` through `<h6>` tags
- Markdown: Renders with `#` symbols equal to the level
- Only use level 1 headings for document titles
- Maintain a logical heading hierarchy (don't skip levels)

## Paragraph Blocks

Paragraph blocks are the most common block type, representing standard text content.

```javascript
const paragraphBlock = Block.createParagraph({
  id: "intro-paragraph",
  content: "BlockDoc is a lightweight structured content format..."
});
```

### Rich Text Support

Paragraphs can contain standard markdown-style formatting:

```javascript
const richTextParagraph = Block.createParagraph({
  id: "rich-text-example",
  content: "This paragraph contains **bold text**, *italics*, and `inline code`."
});
```

When rendered to HTML, the markdown formatting is converted to the appropriate HTML tags.

## List Blocks

List blocks represent ordered (numbered) or unordered (bulleted) lists.

```javascript
const listBlock = Block.createList({
  id: "features-list",
  items: [
    "Block-based content structure",
    "Semantic IDs for each block",
    "Easy conversion to multiple formats"
  ],
  ordered: false // true for numbered lists, false for bullet points
});
```

### Nested Lists

The list item content can include markdown-style sub-lists:

```javascript
const nestedListBlock = Block.createList({
  id: "nested-features-list",
  items: [
    "Content Structure\n  * Block-based design\n  * Flat hierarchy",
    "Developer Experience\n  * Easy to implement\n  * Flexible rendering"
  ],
  ordered: true
});
```

The renderer will interpret the nested list formatting correctly.

## Code Blocks

Code blocks represent code snippets with optional language highlighting.

```javascript
const codeBlock = Block.createCode({
  id: "example-code",
  content: "const doc = new BlockDocDocument();\ndoc.addBlock(Block.createParagraph({ id: 'p1', content: 'Hello' }));",
  language: "javascript" // Optional language for syntax highlighting
});
```

### Language Support

The `language` property should use standard code identifiers:
- `javascript`, `js`
- `python`, `py`
- `html`
- `css`
- `json`
- `bash`, `sh`
- etc.

## Image Blocks

Image blocks represent embedded images with optional captions.

```javascript
const imageBlock = Block.createImage({
  id: "diagram-image",
  url: "https://example.com/blockdoc-structure.png",
  alt: "BlockDoc document structure diagram",
  caption: "Figure 1: BlockDoc document structure" // Optional caption
});
```

### Image Considerations
- Always provide meaningful `alt` text for accessibility
- The `url` can be a relative or absolute URL
- If using local images, ensure the path is correct for your environment
- Captions are optional but recommended for diagrams and figures

## Quote Blocks

Quote blocks represent blockquotes, typically used for citations or highlighted quotes.

```javascript
const quoteBlock = Block.createQuote({
  id: "important-quote",
  content: "Structured content is the foundation of modern content management.",
  attribution: "Content Strategy Experts" // Optional attribution
});
```

Quote blocks render with appropriate styling to distinguish them from regular paragraphs.

## Horizontal Rule Blocks

Horizontal rule blocks create visual dividers between content sections.

```javascript
const hrBlock = Block.createHorizontalRule({
  id: "section-divider"
});
```

This block type has no additional properties beyond the standard `id` and `type`.

## Custom Block Types

You can extend BlockDoc with custom block types for specialized content.

```javascript
// First, create a validation function for your custom type
function validateCalloutBlock(block) {
  return (
    typeof block.content === "string" &&
    ["info", "warning", "danger", "success"].includes(block.calloutType)
  );
}

// Register the custom block type
Block.registerBlockType("callout", validateCalloutBlock);

// Create a custom block
const calloutBlock = new Block({
  id: "important-notice",
  type: "callout",
  content: "This is an important message that requires attention.",
  calloutType: "warning"
});
```

To render custom blocks, you'll need to extend the renderers with custom rendering functions.

## Block Validation

All blocks are validated against the BlockDoc schema:

```javascript
// Check if a single block is valid
const isValid = Block.validate(myBlock);

// Get validation errors if any
if (!isValid) {
  console.log(Block.getValidationErrors(myBlock));
}
```

## Working with Blocks in Documents

BlockDoc documents manage collections of blocks:

```javascript
import { BlockDocDocument, Block } from 'blockdoc';

// Create a document
const doc = new BlockDocDocument();

// Add blocks
doc.addBlock(Block.createHeading({ 
  id: "title",
  content: "Document Title", 
  level: 1 
}));

doc.addBlock(Block.createParagraph({ 
  id: "intro", 
  content: "Introduction paragraph..." 
}));

// Get a specific block by ID
const introBlock = doc.getBlock("intro");

// Update a block
doc.updateBlock("intro", { 
  content: "Updated introduction paragraph..." 
});

// Remove a block
doc.removeBlock("unused-block-id");

// Insert a block at a specific position
doc.addBlockAt(1, Block.createImage({ 
  id: "header-image",
  url: "/images/header.jpg",
  alt: "Header image" 
}));
```

## Block Transformation

Sometimes you may need to convert blocks from one type to another:

```javascript
// Convert a paragraph to a list
const paragraphBlock = doc.getBlock("content-paragraph");
const listItems = paragraphBlock.content.split(". ")
  .map(item => item.trim())
  .filter(item => item.length > 0);

const listBlock = Block.createList({
  id: paragraphBlock.id, // Keep the same ID for consistency
  items: listItems,
  ordered: true
});

// Replace the paragraph with the list
doc.updateBlock(paragraphBlock.id, listBlock);
```

## Practical Example: Building an Article

Here's a complete example of building an article with various block types:

```javascript
import { BlockDocDocument, Block } from 'blockdoc';

function createArticle() {
  const doc = new BlockDocDocument({
    article: {
      title: "Understanding BlockDoc",
      description: "A guide to using the BlockDoc content format",
      author: "Documentation Team",
      date: new Date().toISOString()
    }
  });

  // Title
  doc.addBlock(Block.createHeading({
    id: "title",
    content: "Understanding BlockDoc",
    level: 1
  }));

  // Introduction
  doc.addBlock(Block.createParagraph({
    id: "intro",
    content: "BlockDoc provides a structured way to create content with a block-based approach. This article explains the key concepts and features."
  }));

  // Section: What is BlockDoc
  doc.addBlock(Block.createHeading({
    id: "what-is-blockdoc",
    content: "What is BlockDoc?",
    level: 2
  }));

  doc.addBlock(Block.createParagraph({
    id: "blockdoc-definition",
    content: "BlockDoc is a lightweight structured content format designed for creating modular, block-based content with a focus on simplicity and flexibility."
  }));

  doc.addBlock(Block.createQuote({
    id: "blockdoc-quote",
    content: "BlockDoc makes content creation and management more efficient by breaking down content into logical, semantically named blocks.",
    attribution: "BlockDoc Documentation"
  }));

  // Section: Key Features
  doc.addBlock(Block.createHeading({
    id: "key-features",
    content: "Key Features",
    level: 2
  }));

  doc.addBlock(Block.createList({
    id: "features-list",
    items: [
      "Block-based content structure",
      "Semantic IDs for each block",
      "Multiple output formats (HTML, Markdown)",
      "Easy integration with LLMs",
      "Schema validation"
    ],
    ordered: false
  }));

  // Section: Code Example
  doc.addBlock(Block.createHeading({
    id: "code-example",
    content: "Code Example",
    level: 2
  }));

  doc.addBlock(Block.createParagraph({
    id: "code-intro",
    content: "Here's a simple example of creating a BlockDoc document:"
  }));

  doc.addBlock(Block.createCode({
    id: "sample-code",
    content: `import { BlockDocDocument, Block } from 'blockdoc';

const doc = new BlockDocDocument();
doc.addBlock(Block.createHeading({
  id: "welcome",
  content: "Welcome to BlockDoc",
  level: 1
}));

doc.addBlock(Block.createParagraph({
  id: "description",
  content: "This is a simple example document."
}));`,
    language: "javascript"
  }));

  // Visual divider
  doc.addBlock(Block.createHorizontalRule({
    id: "divider"
  }));

  // Conclusion
  doc.addBlock(Block.createHeading({
    id: "conclusion",
    content: "Conclusion",
    level: 2
  }));

  doc.addBlock(Block.createParagraph({
    id: "conclusion-text",
    content: "BlockDoc provides a flexible foundation for building structured content systems. By leveraging its block-based approach, you can create rich, maintainable content that can be rendered in multiple formats."
  }));

  return doc;
}

const article = createArticle();
console.log(JSON.stringify(article.toJSON(), null, 2));
```

## Best Practices for Block Usage

1. **Use Semantic IDs**: Create meaningful block IDs that describe the content's purpose
2. **Maintain Heading Hierarchy**: Follow proper heading levels (h1 → h2 → h3)
3. **Separate Concerns**: Keep logical content units in separate blocks
4. **Limit Block Size**: Prefer multiple smaller blocks over very large blocks
5. **Use Appropriate Block Types**: Choose the right block type for your content
6. **Balance Block Granularity**: Too many tiny blocks can be as problematic as too few large blocks
7. **Validate Regularly**: Check document validity when making structural changes

## Advanced: Creating Block Collections

For reusable content patterns, you can create block collections:

```javascript
function createFAQBlocks(faqs) {
  const blocks = [];
  
  faqs.forEach((faq, index) => {
    // Question heading
    blocks.push(Block.createHeading({
      id: `faq-q-${index}`,
      content: faq.question,
      level: 3
    }));
    
    // Answer paragraph
    blocks.push(Block.createParagraph({
      id: `faq-a-${index}`,
      content: faq.answer
    }));
  });
  
  return blocks;
}

// Usage
const faqData = [
  { question: "What is BlockDoc?", answer: "BlockDoc is a content structure..." },
  { question: "Why use BlockDoc?", answer: "BlockDoc makes content management..." }
];

const faqBlocks = createFAQBlocks(faqData);
faqBlocks.forEach(block => doc.addBlock(block));
```

## Conclusion

BlockDoc's block types provide a flexible foundation for creating structured content. By understanding each block type's purpose and capabilities, you can build rich, maintainable documents that can be easily rendered in multiple formats and integrated with modern content workflows.

For a complete reference of all block types and their properties, see the [BlockDoc specification](../spec/blockdoc-specification.md).
</file>

<file path="docs/tutorials/getting-started.md">
# Getting Started with BlockDoc

This tutorial walks you through the basics of using BlockDoc to create, manipulate, and render structured content.

## Installation

Install BlockDoc via npm:

```bash
npm install blockdoc
```

## Creating Your First Document

Let's create a simple blog post using BlockDoc:

```javascript
import { BlockDocDocument, Block } from 'blockdoc';

// Create a new document
const doc = new BlockDocDocument({
  article: {
    title: "My First BlockDoc Post",
    description: "Learning how to use BlockDoc",
    author: "Your Name",
    date: new Date().toISOString()
  }
});

// Add heading block
doc.addBlock(
  Block.createHeading({
    id: "intro-heading",
    content: "Introduction to BlockDoc",
    level: 1
  })
);

// Add paragraph block
doc.addBlock(
  Block.createParagraph({
    id: "intro-paragraph",
    content: "BlockDoc is a lightweight structured content format designed for creating modular, block-based content that works well with LLMs."
  })
);

// Add code block
doc.addBlock(
  Block.createCode({
    id: "example-code",
    content: "const doc = new BlockDocDocument();",
    language: "javascript"
  })
);

// Add list block
doc.addBlock(
  Block.createList({
    id: "features-list",
    items: [
      "Modular block-based content",
      "Optimized for LLM generation and modification",
      "Simple flat structure with semantic IDs",
      "Easy storage in databases",
      "Targeted updates to specific sections"
    ],
    ordered: false
  })
);

// Export as JSON
const json = doc.toJSON();
console.log(JSON.stringify(json, null, 2));
```

## Rendering Documents

BlockDoc provides renderers for HTML and Markdown:

### HTML Rendering

```javascript
import { HTMLRenderer } from 'blockdoc';

const renderer = new HTMLRenderer();
const html = renderer.render(doc);
console.log(html);
```

### Markdown Rendering

```javascript
import { MarkdownRenderer } from 'blockdoc';

const renderer = new MarkdownRenderer();
const markdown = renderer.render(doc);
console.log(markdown);
```

## Manipulating Documents

BlockDoc documents can be easily manipulated:

```javascript
// Update a block by ID
doc.updateBlock("intro-paragraph", {
  content: "Updated content for this paragraph."
});

// Remove a block
doc.removeBlock("example-code");

// Add a new block at a specific position
doc.addBlockAt(
  1,
  Block.createImage({
    id: "intro-image",
    url: "https://example.com/image.jpg",
    alt: "An example image",
    caption: "Figure 1: BlockDoc Structure"
  })
);
```

## Validating Documents

BlockDoc validates documents against its schema:

```javascript
// Check if document is valid
const isValid = doc.validate();
console.log(`Document is valid: ${isValid}`);

// Get validation errors if any
if (!isValid) {
  console.log(doc.validationErrors);
}
```

## Working with the API

### Client-Side

```javascript
import { BlockDocClient } from 'blockdoc';

const client = new BlockDocClient('https://api.example.com/blockdoc');

// Fetch a document
const doc = await client.getDocument('document-id');

// Update a document
await client.updateDocument('document-id', doc);
```

### Server-Side

```javascript
import express from 'express';
import { blockDocMiddleware } from 'blockdoc';

const app = express();
const documentsPath = './documents';

// Add BlockDoc middleware
app.use('/api/documents', blockDocMiddleware({
  storagePath: documentsPath
}));

app.listen(3000, () => {
  console.log('BlockDoc API server running on port 3000');
});
```

## Using with React

```jsx
import React from 'react';
import { BlockDocRenderer } from 'blockdoc/react';

function App() {
  const documentData = {
    article: {
      title: "My React BlockDoc Example"
    },
    blocks: [
      {
        id: "heading",
        type: "heading",
        content: "Hello from React!",
        level: 1
      },
      {
        id: "paragraph",
        type: "paragraph",
        content: "This is BlockDoc rendered in React."
      }
    ]
  };

  return (
    <div className="app">
      <BlockDocRenderer document={documentData} />
    </div>
  );
}

export default App;
```

## Next Steps

- Explore [advanced block types](../api-docs/block-types.md)
- Learn about [schema customization](../api-docs/schema-customization.md)
- Check out [LLM integration examples](../../examples/llm-integration/llm-integration-example.js)

For more detailed information, refer to the [BlockDoc specification](../spec/blockdoc-specification.md).
</file>

<file path="docs/tutorials/llm-integration.md">
# Integrating BlockDoc with LLMs

This tutorial explains how to use BlockDoc with Large Language Models (LLMs) to generate and modify structured content.

## Prerequisites

- BlockDoc installed in your project
- OpenAI API key or access to another LLM provider

## Why BlockDoc Works Well with LLMs

BlockDoc's structured format makes it ideal for LLM integration:

1. **Semantic Structure**: The block-based approach with typed content aligns with how LLMs process information
2. **Targeted Generation**: LLMs can generate or update specific blocks without needing to regenerate entire documents
3. **Stable References**: Semantic IDs allow for consistent referencing even as content changes
4. **Schema Validation**: Ensures LLM-generated content maintains structural integrity

## Basic LLM Integration

Here's a simple example using OpenAI's API to generate a BlockDoc document:

```javascript
import { BlockDocDocument, Block } from 'blockdoc';
import { Configuration, OpenAIApi } from 'openai';

// Set up OpenAI
const configuration = new Configuration({
  apiKey: process.env.OPENAI_API_KEY,
});
const openai = new OpenAIApi(configuration);

async function generateBlockDocContent(topic) {
  // Create an empty document with metadata
  const doc = new BlockDocDocument({
    article: {
      title: `Article about ${topic}`,
      description: `An AI-generated article about ${topic}`,
      author: "AI Assistant",
      date: new Date().toISOString()
    }
  });
  
  // Generate a heading
  doc.addBlock(
    Block.createHeading({
      id: "main-heading",
      content: `Understanding ${topic}`,
      level: 1
    })
  );
  
  // Use LLM to generate introduction
  const introResponse = await openai.createChatCompletion({
    model: "gpt-4",
    messages: [{
      role: "system",
      content: "You are a helpful assistant that generates concise, informative content."
    }, {
      role: "user",
      content: `Write a short introduction paragraph about ${topic}. Be informative and engaging.`
    }],
    max_tokens: 200,
  });
  
  const introContent = introResponse.data.choices[0].message.content.trim();
  
  // Add LLM-generated introduction
  doc.addBlock(
    Block.createParagraph({
      id: "introduction",
      content: introContent
    })
  );
  
  // Generate key points heading
  doc.addBlock(
    Block.createHeading({
      id: "key-points-heading",
      content: `Key Points About ${topic}`,
      level: 2
    })
  );
  
  // Use LLM to generate key points
  const pointsResponse = await openai.createChatCompletion({
    model: "gpt-4",
    messages: [{
      role: "system",
      content: "You are a helpful assistant that generates concise, informative content."
    }, {
      role: "user",
      content: `Generate 5 key points about ${topic}. Return them as a numbered list, with each point being 1-2 sentences.`
    }],
    max_tokens: 400,
  });
  
  // Extract the list items from the response
  const pointsContent = pointsResponse.data.choices[0].message.content.trim();
  const listItems = pointsContent
    .split(/\d+\.\s+/) // Split by numbered list items
    .slice(1) // Remove empty first element
    .map(item => item.trim());
  
  // Add LLM-generated list
  doc.addBlock(
    Block.createList({
      id: "key-points-list",
      items: listItems,
      ordered: true
    })
  );
  
  // Use LLM to generate a conclusion
  const conclusionResponse = await openai.createChatCompletion({
    model: "gpt-4",
    messages: [{
      role: "system",
      content: "You are a helpful assistant that generates concise, informative content."
    }, {
      role: "user", 
      content: `Write a short conclusion paragraph about ${topic}. Summarize the importance and relevance.`
    }],
    max_tokens: 200,
  });
  
  const conclusionContent = conclusionResponse.data.choices[0].message.content.trim();
  
  // Add LLM-generated conclusion
  doc.addBlock(
    Block.createParagraph({
      id: "conclusion",
      content: conclusionContent
    })
  );
  
  return doc;
}

// Usage example
async function main() {
  try {
    const topic = "artificial intelligence ethics";
    const document = await generateBlockDocContent(topic);
    
    console.log(JSON.stringify(document.toJSON(), null, 2));
    
    // Validate the generated document
    const isValid = document.validate();
    console.log(`Document is valid: ${isValid}`);
    
    if (!isValid) {
      console.log(document.validationErrors);
    }
  } catch (error) {
    console.error("Error:", error);
  }
}

main();
```

## Targeted Block Updates

One of BlockDoc's strengths is the ability to update specific blocks:

```javascript
async function updateBlock(doc, blockId, prompt) {
  // Get the existing block to determine its type
  const existingBlock = doc.getBlock(blockId);
  
  if (!existingBlock) {
    throw new Error(`Block with ID ${blockId} not found`);
  }
  
  const response = await openai.createChatCompletion({
    model: "gpt-4",
    messages: [{
      role: "system",
      content: "You are a helpful assistant that updates content while maintaining its structure and purpose."
    }, {
      role: "user",
      content: `Update the following content based on this instruction: "${prompt}"\n\nContent to update: "${existingBlock.content}"`
    }],
    max_tokens: 300,
  });
  
  const updatedContent = response.data.choices[0].message.content.trim();
  
  // Update only the specific block
  doc.updateBlock(blockId, { content: updatedContent });
  
  return doc;
}

// Example usage
const updatedDoc = await updateBlock(
  document,
  "introduction", 
  "Make this introduction more focused on the ethical challenges of AI"
);
```

## Generating Structured Content with Requirements

You can provide specific requirements to guide LLM generation:

```javascript
async function generateStructuredSection(doc, topic, requirements) {
  // Generate section heading
  doc.addBlock(
    Block.createHeading({
      id: `${topic.toLowerCase().replace(/\s+/g, '-')}-heading`,
      content: topic,
      level: 2
    })
  );
  
  // Detailed prompt with requirements
  const prompt = `
    Generate content about "${topic}" with the following requirements:
    
    ${requirements.join('\n')}
    
    Format as a cohesive paragraph focusing on the most important aspects.
  `;
  
  const response = await openai.createChatCompletion({
    model: "gpt-4",
    messages: [{
      role: "system",
      content: "You are a helpful assistant that generates high-quality, structured content."
    }, {
      role: "user",
      content: prompt
    }],
    max_tokens: 350,
  });
  
  const content = response.data.choices[0].message.content.trim();
  
  // Add paragraph
  doc.addBlock(
    Block.createParagraph({
      id: `${topic.toLowerCase().replace(/\s+/g, '-')}-content`,
      content: content
    })
  );
  
  return doc;
}

// Example usage
const requirements = [
  "Include at least one specific example",
  "Address both benefits and challenges",
  "Mention recent developments",
  "Keep it accessible to non-technical readers"
];

await generateStructuredSection(document, "AI in Healthcare", requirements);
```

## Converting LLM Outputs to BlockDoc

Sometimes you may want to convert existing LLM outputs into BlockDoc format:

```javascript
async function convertTextToBlockDoc(text, title) {
  // Create a new document
  const doc = new BlockDocDocument({
    article: {
      title: title,
      description: `Generated document about ${title}`,
      author: "AI Assistant",
      date: new Date().toISOString()
    }
  });
  
  // Ask the LLM to identify the structure
  const structurePrompt = `
    Analyze the following text and identify its structure. 
    Break it down into sections with headings and paragraphs.
    Return a JSON structure with the following format:
    [
      { "type": "heading", "content": "Heading text", "level": 1 or 2 },
      { "type": "paragraph", "content": "Paragraph text" },
      ...
    ]
    
    TEXT TO ANALYZE:
    ${text}
  `;
  
  const response = await openai.createChatCompletion({
    model: "gpt-4",
    messages: [{
      role: "system",
      content: "You are a helpful assistant that analyzes text structure and returns valid JSON."
    }, {
      role: "user",
      content: structurePrompt
    }],
    max_tokens: 1500,
  });
  
  let blocks;
  try {
    blocks = JSON.parse(response.data.choices[0].message.content.trim());
  } catch (e) {
    console.error("Failed to parse LLM response as JSON");
    throw e;
  }
  
  // Convert structure to BlockDoc blocks
  let counter = 0;
  for (const block of blocks) {
    const id = `block-${counter++}`;
    
    if (block.type === "heading") {
      doc.addBlock(
        Block.createHeading({
          id,
          content: block.content,
          level: block.level || 2
        })
      );
    } else if (block.type === "paragraph") {
      doc.addBlock(
        Block.createParagraph({
          id,
          content: block.content
        })
      );
    } else if (block.type === "list") {
      doc.addBlock(
        Block.createList({
          id,
          items: block.items || [],
          ordered: block.ordered || false
        })
      );
    }
  }
  
  return doc;
}
```

## Advanced: Generating Multi-Part Documents

For longer documents, you can use a structured approach:

```javascript
async function generateComplexDocument(topic, sections) {
  const doc = new BlockDocDocument({
    article: {
      title: topic,
      description: `Comprehensive guide to ${topic}`,
      author: "AI Assistant",
      date: new Date().toISOString()
    }
  });
  
  // Add main title
  doc.addBlock(
    Block.createHeading({
      id: "main-title",
      content: topic,
      level: 1
    })
  );
  
  // Generate introduction
  const introResponse = await openai.createChatCompletion({
    model: "gpt-4",
    messages: [{
      role: "system",
      content: "You are a helpful assistant that generates concise, informative content."
    }, {
      role: "user",
      content: `Write an introduction for a comprehensive guide about ${topic}. Keep it under 200 words.`
    }],
    max_tokens: 300,
  });
  
  doc.addBlock(
    Block.createParagraph({
      id: "introduction",
      content: introResponse.data.choices[0].message.content.trim()
    })
  );
  
  // Generate each section
  let sectionIndex = 0;
  for (const section of sections) {
    const sectionId = `section-${sectionIndex++}`;
    
    // Add section heading
    doc.addBlock(
      Block.createHeading({
        id: `${sectionId}-heading`,
        content: section.title,
        level: 2
      })
    );
    
    // Generate section content
    const sectionPrompt = `
      Write content for the "${section.title}" section of a guide about ${topic}.
      Focus on these aspects: ${section.aspects.join(', ')}.
      Be informative, accurate, and concise.
    `;
    
    const sectionResponse = await openai.createChatCompletion({
      model: "gpt-4",
      messages: [{
        role: "system",
        content: "You are a helpful assistant that generates well-structured content."
      }, {
        role: "user",
        content: sectionPrompt
      }],
      max_tokens: 500,
    });
    
    const content = sectionResponse.data.choices[0].message.content.trim();
    
    // Split by paragraphs and add them as separate blocks
    const paragraphs = content.split(/\n\n+/);
    
    paragraphs.forEach((paragraph, i) => {
      doc.addBlock(
        Block.createParagraph({
          id: `${sectionId}-paragraph-${i}`,
          content: paragraph.trim()
        })
      );
    });
  }
  
  return doc;
}

// Example usage
const sections = [
  {
    title: "Historical Context",
    aspects: ["key developments", "major milestones", "evolutionary path"]
  },
  {
    title: "Current Applications",
    aspects: ["industry use cases", "consumer impact", "leading innovations"]
  },
  {
    title: "Future Directions",
    aspects: ["emerging trends", "potential breakthroughs", "challenges ahead"]
  }
];

const complexDocument = await generateComplexDocument("Quantum Computing", sections);
```

## Best Practices for LLM Integration

1. **Provide Clear Directives**: Give the LLM specific instructions about content style, length, and focus
2. **Validate Generated Content**: Always validate documents against the BlockDoc schema
3. **Use Semantic IDs**: Create meaningful IDs that reflect content purpose for easier updates
4. **Generate Incrementally**: Build documents block by block rather than all at once
5. **Consider Temperature Settings**: Lower temperature (0.1-0.4) for factual content, higher (0.6-0.8) for creative content
6. **Handle Errors Gracefully**: LLM responses may occasionally fail to parse or meet requirements

## Conclusion

BlockDoc's structured approach to content makes it an excellent choice for LLM integration. By leveraging the block-based architecture and semantic IDs, you can create sophisticated workflows for generating, updating, and managing content with LLMs.

For more advanced examples, check out the [LLM integration example](../../examples/llm-integration/llm-integration-example.js) in the examples directory.
</file>

<file path="examples/react-demo/App.jsx">
/**
 * BlockDoc React Demo
 *
 * This is a simple React app that demonstrates using BlockDoc in a React application
 */

import React, { useState } from 'react';
import { BlockDocRenderer } from './BlockDocRenderer';
import { BlockDocDocument, Block } from '../../src/index';

export default function App() {
  // Create a sample document
  const [document] = useState(() => {
    // Create a new document
    const doc = new BlockDocDocument({
      title: "BlockDoc React Demo",
      metadata: {
        author: "BlockDoc Team",
        publishedDate: new Date().toISOString(),
        tags: ["react", "blockdoc", "demo"]
      }
    });

    // Add blocks
    doc.addBlock(Block.text(
      "intro",
      "This is a demo of how to use **BlockDoc** with React. The component renders each block type appropriately."
    ));

    doc.addBlock(Block.heading(
      "block-types",
      2,
      "Block Types Demo"
    ));

    doc.addBlock(Block.text(
      "block-types-intro",
      "BlockDoc supports various block types, each with its own rendering behavior. Here are some examples:"
    ));

    // Add a code example
    doc.addBlock(Block.code(
      "react-example",
      "jsx",
      `import { BlockDocRenderer } from 'blockdoc/react';

// Use the renderer component
function MyComponent() {
  return (
    <BlockDocRenderer document={myDocument} />
  );
}`
    ));

    // Add an image
    doc.addBlock(Block.image(
      "demo-image",
      "https://placehold.co/600x200?text=BlockDoc+React",
      "BlockDoc React Demo",
      "A sample image with caption"
    ));

    // Add a list
    doc.addBlock(Block.list(
      "feature-list",
      [
        "Component-based rendering",
        "Markdown support in text blocks",
        "Semantic block IDs",
        "Custom styling options"
      ],
      "unordered"
    ));

    // Add a quote
    const quoteBlock = new Block({
      id: "react-quote",
      type: "quote",
      content: "BlockDoc makes it easy to create structured content that renders beautifully in React applications.",
      attribution: "BlockDoc Documentation"
    });
    doc.addBlock(quoteBlock);

    return doc;
  });

  return (
    <div className="app">
      <BlockDocRenderer document={document} />
      
      <div className="demo-controls">
        <h3>Document JSON:</h3>
        <pre className="json-preview">
          {JSON.stringify(document.toJSON(), null, 2)}
        </pre>
      </div>
    </div>
  );
}
</file>

<file path="examples/react-demo/BlockDocRenderer.jsx">
/**
 * BlockDoc React Renderer Component
 *
 * This is a simple React component for rendering BlockDoc documents
 * Note: This is just a basic example and doesn't include styles
 */

import React from 'react';
import { marked } from 'marked';

/**
 * Render a BlockDoc document as React components
 * @param {Object} props - Component props
 * @param {Object} props.document - BlockDoc document object
 * @returns {React.Component} Rendered document
 */
export function BlockDocRenderer({ document }) {
  if (!document || !document.article) {
    return <div className="blockdoc-error">Invalid document</div>;
  }

  const { title, metadata, blocks } = document.article;

  return (
    <article className="blockdoc-article">
      <header className="blockdoc-header">
        <h1 className="blockdoc-title">{title}</h1>
        {metadata && <DocumentMeta metadata={metadata} />}
      </header>

      <div className="blockdoc-content">
        {blocks.map(block => (
          <BlockRenderer key={block.id} block={block} />
        ))}
      </div>
    </article>
  );
}

/**
 * Render document metadata
 */
function DocumentMeta({ metadata }) {
  return (
    <div className="blockdoc-metadata">
      {metadata.author && (
        <div className="blockdoc-author">By {metadata.author}</div>
      )}
      
      {metadata.publishedDate && (
        <div className="blockdoc-date">
          {new Date(metadata.publishedDate).toLocaleDateString()}
        </div>
      )}
      
      {metadata.tags && metadata.tags.length > 0 && (
        <div className="blockdoc-tags">
          {metadata.tags.map(tag => (
            <span key={tag} className="blockdoc-tag">
              {tag}
            </span>
          ))}
        </div>
      )}
    </div>
  );
}

/**
 * Render a single block based on its type
 */
function BlockRenderer({ block }) {
  const { id, type } = block;
  
  // Wrapper with data attributes
  const blockClass = `blockdoc-block blockdoc-${type}`;
  const blockProps = {
    className: blockClass,
    'data-block-id': id,
    'data-block-type': type,
  };
  
  // Render based on block type
  switch (type) {
    case 'text':
      return <TextBlock block={block} blockProps={blockProps} />;
    case 'heading':
      return <HeadingBlock block={block} blockProps={blockProps} />;
    case 'image':
      return <ImageBlock block={block} blockProps={blockProps} />;
    case 'code':
      return <CodeBlock block={block} blockProps={blockProps} />;
    case 'list':
      return <ListBlock block={block} blockProps={blockProps} />;
    case 'quote':
      return <QuoteBlock block={block} blockProps={blockProps} />;
    case 'embed':
      return <EmbedBlock block={block} blockProps={blockProps} />;
    case 'divider':
      return <div {...blockProps}><hr className="blockdoc-divider" /></div>;
    default:
      return (
        <div {...blockProps}>
          <p>Unknown block type: {type}</p>
        </div>
      );
  }
}

/**
 * Render a text block (with markdown)
 */
function TextBlock({ block, blockProps }) {
  return (
    <div {...blockProps}>
      <div 
        className="blockdoc-text-content"
        dangerouslySetInnerHTML={{ __html: marked.parse(block.content) }} 
      />
    </div>
  );
}

/**
 * Render a heading block
 */
function HeadingBlock({ block, blockProps }) {
  const { level, content } = block;
  const validLevel = Math.min(Math.max(parseInt(level) || 2, 1), 6);
  
  const HeadingTag = `h${validLevel}`;
  
  return (
    <div {...blockProps}>
      <HeadingTag className="blockdoc-heading">{content}</HeadingTag>
    </div>
  );
}

/**
 * Render an image block
 */
function ImageBlock({ block, blockProps }) {
  const { url, alt, caption } = block;
  
  if (caption) {
    return (
      <figure {...blockProps} className={`${blockProps.className} blockdoc-figure`}>
        <img src={url} alt={alt} className="blockdoc-image" />
        <figcaption className="blockdoc-caption">{caption}</figcaption>
      </figure>
    );
  }
  
  return (
    <div {...blockProps}>
      <img src={url} alt={alt} className="blockdoc-image" />
    </div>
  );
}

/**
 * Render a code block
 */
function CodeBlock({ block, blockProps }) {
  const { language, content } = block;
  
  return (
    <div {...blockProps}>
      <pre className="blockdoc-pre">
        <code className={`blockdoc-code ${language ? `language-${language}` : ''}`}>
          {content}
        </code>
      </pre>
    </div>
  );
}

/**
 * Render a list block
 */
function ListBlock({ block, blockProps }) {
  const { items, listType } = block;
  
  if (!items || !Array.isArray(items)) {
    return (
      <div {...blockProps}>
        <p>Invalid list items</p>
      </div>
    );
  }
  
  const ListTag = listType === 'ordered' ? 'ol' : 'ul';
  const listClass = `blockdoc-list blockdoc-list-${listType}`;
  
  return (
    <div {...blockProps}>
      <ListTag className={listClass}>
        {items.map((item, index) => (
          <li 
            key={index} 
            dangerouslySetInnerHTML={{ __html: marked.parse(item) }} 
          />
        ))}
      </ListTag>
    </div>
  );
}

/**
 * Render a quote block
 */
function QuoteBlock({ block, blockProps }) {
  const { content, attribution } = block;
  
  return (
    <div {...blockProps}>
      <blockquote 
        className="blockdoc-quote"
        dangerouslySetInnerHTML={{ __html: marked.parse(content) }} 
      />
      {attribution && (
        <cite className="blockdoc-attribution">{attribution}</cite>
      )}
    </div>
  );
}

/**
 * Render an embed block
 */
function EmbedBlock({ block, blockProps }) {
  const { url, caption, embedType } = block;
  
  let embedContent;
  
  if (embedType === 'youtube') {
    const videoId = extractYouTubeId(url);
    
    if (videoId) {
      embedContent = (
        <div className="blockdoc-embed-container">
          <iframe 
            width="560" 
            height="315" 
            src={`https://www.youtube.com/embed/${videoId}`}
            frameBorder="0" 
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
            allowFullScreen
            title={caption || 'YouTube video'}
          />
        </div>
      );
    } else {
      embedContent = <p>Invalid YouTube URL</p>;
    }
  } else {
    // Generic embed
    embedContent = (
      <div className="blockdoc-embed">
        <iframe 
          src={url} 
          frameBorder="0" 
          width="100%" 
          height="400"
          allowFullScreen
          title={caption || 'Embedded content'}
        />
      </div>
    );
  }
  
  if (caption) {
    return (
      <figure {...blockProps} className={`${blockProps.className} blockdoc-figure`}>
        {embedContent}
        <figcaption className="blockdoc-caption">{caption}</figcaption>
      </figure>
    );
  }
  
  return <div {...blockProps}>{embedContent}</div>;
}

/**
 * Extract YouTube video ID from URL
 */
function extractYouTubeId(url) {
  try {
    const parsedUrl = new URL(url);
    
    // Handle youtu.be format
    if (parsedUrl.hostname === 'youtu.be') {
      return parsedUrl.pathname.slice(1);
    }
    
    // Handle youtube.com format
    if (parsedUrl.hostname === 'www.youtube.com' || parsedUrl.hostname === 'youtube.com') {
      const params = new URLSearchParams(parsedUrl.search);
      return params.get('v');
    }
    
    return null;
  } catch (e) {
    return null;
  }
}
</file>

<file path="examples/simple-blog/output/blog-post-updated.json">
{
  "article": {
    "title": "Getting Started with BlockDoc",
    "metadata": {
      "author": "BlockDoc Team",
      "publishedDate": "2025-03-23T16:46:26.381Z",
      "tags": [
        "blockdoc",
        "tutorial",
        "content",
        "structured-data"
      ]
    },
    "blocks": [
      {
        "id": "intro",
        "type": "text",
        "content": "Welcome to **BlockDoc**, a simple yet powerful format for structured content. In this tutorial, we'll explore the basics of creating and working with BlockDoc documents."
      },
      {
        "id": "what-is-blockdoc",
        "type": "heading",
        "content": "What is BlockDoc?",
        "level": 2
      },
      {
        "id": "blockdoc-explanation",
        "type": "text",
        "content": "BlockDoc is a powerful structured content format designed for:\n\n* **LLM-friendly** - Optimized for generation and modification by AI\n* **Block-based** - Content is divided into modular blocks with semantic IDs\n* **Flexible** - Supports various content types and nested structures\n* **Database-ready** - Easy to store in document databases\n* **Renderer-agnostic** - Output to HTML, Markdown, or other formats\n* **Version control friendly** - Easy to track changes to specific content blocks"
      },
      {
        "id": "code-example",
        "type": "code",
        "content": "// Create a new BlockDoc document\nconst doc = new BlockDocDocument({\n  title: \"My First Document\",\n});\n\n// Add some content blocks\ndoc.addBlock(Block.heading(\"intro-heading\", 2, \"Introduction\"));\ndoc.addBlock(Block.text(\"intro-text\", \"This is my **first** BlockDoc document.\"));\n\n// Render to HTML\nconst html = doc.renderToHTML();\nconsole.log(html);",
        "language": "javascript"
      },
      {
        "id": "sample-image",
        "type": "image",
        "content": "",
        "url": "https://placehold.co/600x400?text=BlockDoc+Example",
        "alt": "A sample BlockDoc document structure",
        "caption": "Figure 1: Visual representation of a BlockDoc document"
      },
      {
        "id": "block-types",
        "type": "heading",
        "content": "Supported Block Types",
        "level": 2
      },
      {
        "id": "block-types-list",
        "type": "list",
        "content": "",
        "items": [
          "**Text**: Markdown-formatted text content",
          "**Heading**: Section headings with levels 1-6",
          "**Image**: Images with URL, alt text, and optional caption",
          "**Code**: Code snippets with language highlighting",
          "**List**: Ordered or unordered lists",
          "**Quote**: Blockquotes with optional attribution",
          "**Embed**: Embedded content like videos or tweets",
          "**Divider**: Horizontal dividers between sections"
        ],
        "listType": "unordered"
      },
      {
        "id": "quote-intro",
        "type": "text",
        "content": "BlockDoc was designed with a specific philosophy in mind:"
      },
      {
        "id": "philosophy-quote",
        "type": "quote",
        "content": "Content should be structured in a way that is meaningful to both humans and machines, allowing for precise updates and transformations while maintaining semantic context.",
        "attribution": "BlockDoc Design Principles"
      },
      {
        "id": "conclusion",
        "type": "heading",
        "content": "Getting Started",
        "level": 2
      },
      {
        "id": "conclusion-text",
        "type": "text",
        "content": "Ready to try BlockDoc for yourself? Check out our [GitHub repository](https://github.com/berrydev-ai/blockdoc) and follow the installation instructions to get started.\n\nBlockDoc is perfect for content-heavy applications, CMS systems, documentation sites, and anywhere else you need structured, maintainable content."
      },
      {
        "id": "end-divider",
        "type": "divider",
        "content": ""
      }
    ]
  }
}
</file>

<file path="examples/simple-blog/output/blog-post.html">
<article class="blockdoc-article">
<h1 class="blockdoc-title">Getting Started with BlockDoc</h1>
<div class="blockdoc-block blockdoc-text" data-block-id="intro" data-block-type="text"><p>Welcome to <strong>BlockDoc</strong>, a simple yet powerful format for structured content. In this tutorial, we&#39;ll explore the basics of creating and working with BlockDoc documents.</p>
</div>
<div class="blockdoc-block blockdoc-heading" data-block-id="what-is-blockdoc" data-block-type="heading"><h2>What is BlockDoc?</h2></div>
<div class="blockdoc-block blockdoc-text" data-block-id="blockdoc-explanation" data-block-type="text"><p>BlockDoc is a structured content format designed for:</p>
<ul>
<li><strong>LLM-friendly</strong> - Optimized for generation and modification by AI</li>
<li><strong>Block-based</strong> - Content is divided into modular blocks with semantic IDs</li>
<li><strong>Flexible</strong> - Supports various content types and nested structures</li>
<li><strong>Database-ready</strong> - Easy to store in document databases</li>
<li><strong>Renderer-agnostic</strong> - Output to HTML, Markdown, or other formats</li>
</ul>
</div>
<div class="blockdoc-block blockdoc-code" data-block-id="code-example" data-block-type="code">
    <pre class="blockdoc-pre">
      <code class="blockdoc-code language-javascript"><span class="hljs-comment">// Create a new BlockDoc document</span>
<span class="hljs-keyword">const</span> doc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockDocDocument</span>({
  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;My First Document&quot;</span>,
});

<span class="hljs-comment">// Add some content blocks</span>
doc.<span class="hljs-title function_">addBlock</span>(<span class="hljs-title class_">Block</span>.<span class="hljs-title function_">heading</span>(<span class="hljs-string">&quot;intro-heading&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;Introduction&quot;</span>));
doc.<span class="hljs-title function_">addBlock</span>(<span class="hljs-title class_">Block</span>.<span class="hljs-title function_">text</span>(<span class="hljs-string">&quot;intro-text&quot;</span>, <span class="hljs-string">&quot;This is my **first** BlockDoc document.&quot;</span>));

<span class="hljs-comment">// Render to HTML</span>
<span class="hljs-keyword">const</span> html = doc.<span class="hljs-title function_">renderToHTML</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(html);</code>
    </pre>
  </div>
<div class="blockdoc-block blockdoc-image" data-block-id="sample-image" data-block-type="image"><figure class="blockdoc-figure"><img src="https://placehold.co/600x400?text=BlockDoc+Example" alt="A sample BlockDoc document structure" class="blockdoc-image" /><figcaption class="blockdoc-caption">Figure 1: Visual representation of a BlockDoc document</figcaption></figure></div>
<div class="blockdoc-block blockdoc-heading" data-block-id="block-types" data-block-type="heading"><h2>Supported Block Types</h2></div>
<div class="blockdoc-block blockdoc-list" data-block-id="block-types-list" data-block-type="list"><ul class="blockdoc-list blockdoc-list-unordered"><li><p><strong>Text</strong>: Markdown-formatted text content</p>
</li><li><p><strong>Heading</strong>: Section headings with levels 1-6</p>
</li><li><p><strong>Image</strong>: Images with URL, alt text, and optional caption</p>
</li><li><p><strong>Code</strong>: Code snippets with language highlighting</p>
</li><li><p><strong>List</strong>: Ordered or unordered lists</p>
</li><li><p><strong>Quote</strong>: Blockquotes with optional attribution</p>
</li><li><p><strong>Embed</strong>: Embedded content like videos or tweets</p>
</li><li><p><strong>Divider</strong>: Horizontal dividers between sections</p>
</li></ul></div>
<div class="blockdoc-block blockdoc-text" data-block-id="quote-intro" data-block-type="text"><p>BlockDoc was designed with a specific philosophy in mind:</p>
</div>
<div class="blockdoc-block blockdoc-quote" data-block-id="philosophy-quote" data-block-type="quote"><blockquote class="blockdoc-quote"><p>Content should be structured in a way that is meaningful to both humans and machines, allowing for precise updates and transformations while maintaining semantic context.</p>
</blockquote><cite class="blockdoc-attribution">BlockDoc Design Principles</cite></div>
<div class="blockdoc-block blockdoc-heading" data-block-id="conclusion" data-block-type="heading"><h2>Getting Started</h2></div>
<div class="blockdoc-block blockdoc-text" data-block-id="conclusion-text" data-block-type="text"><p>Ready to try BlockDoc for yourself? Check out our <a href="https://github.com/berrydev-ai/blockdoc">GitHub repository</a> and follow the installation instructions to get started.</p>
<p>BlockDoc is perfect for content-heavy applications, CMS systems, documentation sites, and anywhere else you need structured, maintainable content.</p>
</div>
<div class="blockdoc-block blockdoc-divider" data-block-id="end-divider" data-block-type="divider"><hr class="blockdoc-divider" /></div>
</article>
</file>

<file path="examples/simple-blog/output/blog-post.json">
{
  "article": {
    "title": "Getting Started with BlockDoc",
    "metadata": {
      "author": "BlockDoc Team",
      "publishedDate": "2025-03-23T16:46:26.381Z",
      "tags": [
        "blockdoc",
        "tutorial",
        "content",
        "structured-data"
      ]
    },
    "blocks": [
      {
        "id": "intro",
        "type": "text",
        "content": "Welcome to **BlockDoc**, a simple yet powerful format for structured content. In this tutorial, we'll explore the basics of creating and working with BlockDoc documents."
      },
      {
        "id": "what-is-blockdoc",
        "type": "heading",
        "content": "What is BlockDoc?",
        "level": 2
      },
      {
        "id": "blockdoc-explanation",
        "type": "text",
        "content": "BlockDoc is a structured content format designed for:\n\n* **LLM-friendly** - Optimized for generation and modification by AI\n* **Block-based** - Content is divided into modular blocks with semantic IDs\n* **Flexible** - Supports various content types and nested structures\n* **Database-ready** - Easy to store in document databases\n* **Renderer-agnostic** - Output to HTML, Markdown, or other formats"
      },
      {
        "id": "code-example",
        "type": "code",
        "content": "// Create a new BlockDoc document\nconst doc = new BlockDocDocument({\n  title: \"My First Document\",\n});\n\n// Add some content blocks\ndoc.addBlock(Block.heading(\"intro-heading\", 2, \"Introduction\"));\ndoc.addBlock(Block.text(\"intro-text\", \"This is my **first** BlockDoc document.\"));\n\n// Render to HTML\nconst html = doc.renderToHTML();\nconsole.log(html);",
        "language": "javascript"
      },
      {
        "id": "sample-image",
        "type": "image",
        "content": "",
        "url": "https://placehold.co/600x400?text=BlockDoc+Example",
        "alt": "A sample BlockDoc document structure",
        "caption": "Figure 1: Visual representation of a BlockDoc document"
      },
      {
        "id": "block-types",
        "type": "heading",
        "content": "Supported Block Types",
        "level": 2
      },
      {
        "id": "block-types-list",
        "type": "list",
        "content": "",
        "items": [
          "**Text**: Markdown-formatted text content",
          "**Heading**: Section headings with levels 1-6",
          "**Image**: Images with URL, alt text, and optional caption",
          "**Code**: Code snippets with language highlighting",
          "**List**: Ordered or unordered lists",
          "**Quote**: Blockquotes with optional attribution",
          "**Embed**: Embedded content like videos or tweets",
          "**Divider**: Horizontal dividers between sections"
        ],
        "listType": "unordered"
      },
      {
        "id": "quote-intro",
        "type": "text",
        "content": "BlockDoc was designed with a specific philosophy in mind:"
      },
      {
        "id": "philosophy-quote",
        "type": "quote",
        "content": "Content should be structured in a way that is meaningful to both humans and machines, allowing for precise updates and transformations while maintaining semantic context.",
        "attribution": "BlockDoc Design Principles"
      },
      {
        "id": "conclusion",
        "type": "heading",
        "content": "Getting Started",
        "level": 2
      },
      {
        "id": "conclusion-text",
        "type": "text",
        "content": "Ready to try BlockDoc for yourself? Check out our [GitHub repository](https://github.com/berrydev-ai/blockdoc) and follow the installation instructions to get started.\n\nBlockDoc is perfect for content-heavy applications, CMS systems, documentation sites, and anywhere else you need structured, maintainable content."
      },
      {
        "id": "end-divider",
        "type": "divider",
        "content": ""
      }
    ]
  }
}
</file>

<file path="examples/simple-blog/output/blog-post.md">
# Getting Started with BlockDoc

> Author: BlockDoc Team
> Published: Sun Mar 23 2025
> Tags: blockdoc, tutorial, content, structured-data

Welcome to **BlockDoc**, a simple yet powerful format for structured content. In this tutorial, we'll explore the basics of creating and working with BlockDoc documents.

## What is BlockDoc?

BlockDoc is a structured content format designed for:

* **LLM-friendly** - Optimized for generation and modification by AI
* **Block-based** - Content is divided into modular blocks with semantic IDs
* **Flexible** - Supports various content types and nested structures
* **Database-ready** - Easy to store in document databases
* **Renderer-agnostic** - Output to HTML, Markdown, or other formats

```javascript
// Create a new BlockDoc document
const doc = new BlockDocDocument({
  title: "My First Document",
});

// Add some content blocks
doc.addBlock(Block.heading("intro-heading", 2, "Introduction"));
doc.addBlock(Block.text("intro-text", "This is my **first** BlockDoc document."));

// Render to HTML
const html = doc.renderToHTML();
console.log(html);
```

![A sample BlockDoc document structure](https://placehold.co/600x400?text=BlockDoc+Example)
*Figure 1: Visual representation of a BlockDoc document*

## Supported Block Types

- **Text**: Markdown-formatted text content
- **Heading**: Section headings with levels 1-6
- **Image**: Images with URL, alt text, and optional caption
- **Code**: Code snippets with language highlighting
- **List**: Ordered or unordered lists
- **Quote**: Blockquotes with optional attribution
- **Embed**: Embedded content like videos or tweets
- **Divider**: Horizontal dividers between sections

BlockDoc was designed with a specific philosophy in mind:

> Content should be structured in a way that is meaningful to both humans and machines, allowing for precise updates and transformations while maintaining semantic context.
>
>  BlockDoc Design Principles

## Getting Started

Ready to try BlockDoc for yourself? Check out our [GitHub repository](https://github.com/berrydev-ai/blockdoc) and follow the installation instructions to get started.

BlockDoc is perfect for content-heavy applications, CMS systems, documentation sites, and anywhere else you need structured, maintainable content.

---
</file>

<file path="examples/simple-blog/index.js">
/**
 * BlockDoc Simple Blog Example
 *
 * This example demonstrates creating and rendering a blog post using BlockDoc
 */

import { Block, BlockDocDocument } from '../../src/index.js';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

// Get the directory name
const __dirname = path.dirname(fileURLToPath(import.meta.url));

/**
 * Create a sample blog post
 * @returns {BlockDocDocument} The created document
 */
function createBlogPost() {
  // Create a new document
  const blogPost = new BlockDocDocument({
    title: "Getting Started with BlockDoc",
    metadata: {
      author: "BlockDoc Team",
      publishedDate: new Date().toISOString(),
      tags: ["blockdoc", "tutorial", "content", "structured-data"]
    }
  });

  // Add an introduction
  blogPost.addBlock(Block.text(
    "intro",
    "Welcome to **BlockDoc**, a simple yet powerful format for structured content. " +
    "In this tutorial, we'll explore the basics of creating and working with BlockDoc documents."
  ));

  // Add a heading
  blogPost.addBlock(Block.heading(
    "what-is-blockdoc",
    2,
    "What is BlockDoc?"
  ));

  // Add content explaining BlockDoc
  blogPost.addBlock(Block.text(
    "blockdoc-explanation",
    "BlockDoc is a structured content format designed for:\n\n" +
    "* **LLM-friendly** - Optimized for generation and modification by AI\n" +
    "* **Block-based** - Content is divided into modular blocks with semantic IDs\n" +
    "* **Flexible** - Supports various content types and nested structures\n" +
    "* **Database-ready** - Easy to store in document databases\n" +
    "* **Renderer-agnostic** - Output to HTML, Markdown, or other formats"
  ));

  // Add a code example
  blogPost.addBlock(Block.code(
    "code-example",
    "javascript",
    `// Create a new BlockDoc document
const doc = new BlockDocDocument({
  title: "My First Document",
});

// Add some content blocks
doc.addBlock(Block.heading("intro-heading", 2, "Introduction"));
doc.addBlock(Block.text("intro-text", "This is my **first** BlockDoc document."));

// Render to HTML
const html = doc.renderToHTML();
console.log(html);`
  ));

  // Add an image
  blogPost.addBlock(Block.image(
    "sample-image",
    "https://placehold.co/600x400?text=BlockDoc+Example",
    "A sample BlockDoc document structure",
    "Figure 1: Visual representation of a BlockDoc document"
  ));

  // Add another heading
  blogPost.addBlock(Block.heading(
    "block-types",
    2,
    "Supported Block Types"
  ));

  // Add a list of block types
  blogPost.addBlock(Block.list(
    "block-types-list",
    [
      "**Text**: Markdown-formatted text content",
      "**Heading**: Section headings with levels 1-6",
      "**Image**: Images with URL, alt text, and optional caption",
      "**Code**: Code snippets with language highlighting",
      "**List**: Ordered or unordered lists",
      "**Quote**: Blockquotes with optional attribution",
      "**Embed**: Embedded content like videos or tweets",
      "**Divider**: Horizontal dividers between sections"
    ],
    "unordered"
  ));

  // Add a quote
  blogPost.addBlock(Block.text(
    "quote-intro",
    "BlockDoc was designed with a specific philosophy in mind:"
  ));

  const quoteBlock = new Block({
    id: "philosophy-quote",
    type: "quote",
    content: "Content should be structured in a way that is meaningful to both humans and machines, allowing for precise updates and transformations while maintaining semantic context.",
    attribution: "BlockDoc Design Principles"
  });
  
  blogPost.addBlock(quoteBlock);

  // Add a conclusion
  blogPost.addBlock(Block.heading(
    "conclusion",
    2,
    "Getting Started"
  ));

  blogPost.addBlock(Block.text(
    "conclusion-text",
    "Ready to try BlockDoc for yourself? Check out our [GitHub repository](https://github.com/berrydev-ai/blockdoc) and follow the installation instructions to get started.\n\n" +
    "BlockDoc is perfect for content-heavy applications, CMS systems, documentation sites, and anywhere else you need structured, maintainable content."
  ));

  // Add a divider
  blogPost.addBlock(new Block({
    id: "end-divider",
    type: "divider",
    content: ""
  }));

  // Return the document
  return blogPost;
}

/**
 * Main function to run the example
 */
async function runExample() {
  console.log("Creating a sample BlockDoc blog post...");
  const blogPost = createBlogPost();
  
  // Validate the document against the schema
  console.log("Validating against schema...");
  try {
    blogPost.validate();
    console.log("✓ Document is valid");
  } catch (error) {
    console.error("✗ Validation failed:", error.message);
    return;
  }
  
  // Save the document as JSON
  const outputDir = path.join(__dirname, 'output');
  await fs.mkdir(outputDir, { recursive: true });
  
  console.log("Saving document as JSON...");
  await fs.writeFile(
    path.join(outputDir, 'blog-post.json'),
    blogPost.toString(),
    'utf8'
  );
  
  // Render to HTML
  console.log("Rendering to HTML...");
  const html = blogPost.renderToHTML();
  await fs.writeFile(
    path.join(outputDir, 'blog-post.html'),
    html,
    'utf8'
  );
  
  // Render to Markdown
  console.log("Rendering to Markdown...");
  const markdown = blogPost.renderToMarkdown();
  await fs.writeFile(
    path.join(outputDir, 'blog-post.md'),
    markdown,
    'utf8'
  );
  
  // Example of updating a block
  console.log("Updating a block...");
  blogPost.updateBlock("blockdoc-explanation", {
    content: "BlockDoc is a powerful structured content format designed for:\n\n" +
      "* **LLM-friendly** - Optimized for generation and modification by AI\n" +
      "* **Block-based** - Content is divided into modular blocks with semantic IDs\n" +
      "* **Flexible** - Supports various content types and nested structures\n" +
      "* **Database-ready** - Easy to store in document databases\n" +
      "* **Renderer-agnostic** - Output to HTML, Markdown, or other formats\n" +
      "* **Version control friendly** - Easy to track changes to specific content blocks"
  });
  
  console.log("Saving updated document...");
  await fs.writeFile(
    path.join(outputDir, 'blog-post-updated.json'),
    blogPost.toString(),
    'utf8'
  );
  
  console.log("Example complete! Output files saved to:", outputDir);
  console.log("• blog-post.json - The BlockDoc document in JSON format");
  console.log("• blog-post.html - The document rendered to HTML");
  console.log("• blog-post.md - The document rendered to Markdown");
  console.log("• blog-post-updated.json - The document after updating a block");
}

// Run the example
runExample().catch(error => {
  console.error("Example failed:", error);
  process.exit(1);
});
</file>

<file path="examples/README.md">
# BlockDoc Examples

This directory contains example implementations demonstrating how to use BlockDoc in different scenarios.

## Available Examples

### 1. Simple Blog (`simple-blog/`)

A basic example showing how to create, validate, and render a blog post using BlockDoc.

**Features demonstrated:**

- Creating a BlockDoc document with metadata
- Adding different types of blocks (text, heading, code, image, list, quote, divider)
- Validating against the schema
- Rendering to HTML and Markdown
- Updating blocks
- Saving to JSON

**How to run:**

```bash
# From the project root
npm run examples

# Or run directly
node examples/simple-blog/index.js
```

**Output:**
The example will create four files in the `examples/simple-blog/output/` directory:

- `blog-post.json` - The original BlockDoc document in JSON format
- `blog-post.html` - The document rendered to HTML
- `blog-post.md` - The document rendered to Markdown
- `blog-post-updated.json` - The document after updating a block

### 2. React Demo (`react-demo/`)

Demonstrates how to use BlockDoc with React, rendering different block types as React components.

**Features demonstrated:**

- Creating a sample BlockDoc document
- Rendering blocks as React components
- Displaying the document's JSON structure

**How to run:**
Typically used within a React application. This example provides the components you would
import into your React project.

```bash
# For a full React demo, you would import these components into your React app
import { BlockDocRenderer } from './BlockDocRenderer';

# Then use in your components
<BlockDocRenderer document={myDocument} />
```

### 3. LLM Integration (`llm-integration/`)

Shows how to integrate BlockDoc with Large Language Models (LLMs) for content generation and manipulation.

**Features demonstrated:**

- Generating complete articles with structured blocks using an LLM
- Updating specific sections of content
- Extracting keywords and metadata from existing content
- Converting BlockDoc to/from JSON for API interactions

**How to run:**

```bash
# Set your OpenAI API key
export OPENAI_API_KEY=your_api_key_here

# From the project root
node examples/llm-integration/llm-integration-example.js
```

**Note:** Requires an OpenAI API key to run. The example uses GPT-4 for optimal results.

## Creating Your Own Examples

Feel free to create your own examples using BlockDoc. The general pattern is:

1. Import the BlockDoc components

   ```javascript
   import { BlockDocDocument, Block } from "blockdoc"
   ```

2. Create a document and add blocks

   ```javascript
   const doc = new BlockDocDocument({
     title: "My Document",
     metadata: {
       /* optional metadata */
     },
   })

   doc.addBlock(Block.text("intro", "This is my document."))
   ```

3. Render or manipulate the document

   ```javascript
   // Render to HTML
   const html = doc.renderToHTML()

   // Render to Markdown
   const markdown = doc.renderToMarkdown()

   // Convert to JSON
   const json = doc.toString()
   ```

For more information, see the [documentation](../docs/tutorials/getting-started.md).
</file>

<file path="src/schema/blockdoc.schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "BlockDoc Document",
  "description": "A structured text content format optimized for LLMs and targeted content editing",
  "type": "object",
  "required": [
    "article"
  ],
  "properties": {
    "article": {
      "type": "object",
      "required": [
        "title",
        "blocks"
      ],
      "properties": {
        "title": {
          "type": "string",
          "description": "The title of the article"
        },
        "metadata": {
          "type": "object",
          "description": "Optional metadata for the article",
          "properties": {
            "author": {
              "type": "string"
            },
            "publishedDate": {
              "type": "string",
              "format": "date-time"
            },
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        },
        "blocks": {
          "type": "array",
          "description": "The content blocks that make up the article",
          "items": {
            "type": "object",
            "required": [
              "id",
              "type",
              "content"
            ],
            "properties": {
              "id": {
                "type": "string",
                "description": "A unique, semantic identifier for the block",
                "pattern": "^[a-zA-Z0-9-_]+$"
              },
              "type": {
                "type": "string",
                "description": "The type of content block",
                "enum": [
                  "text",
                  "heading",
                  "image",
                  "code",
                  "list",
                  "quote",
                  "embed",
                  "divider"
                ]
              },
              "content": {
                "type": "string",
                "description": "The content of the block, interpreted based on type (markdown for text)"
              },
              "level": {
                "type": "integer",
                "description": "The level for heading blocks (1-6)",
                "minimum": 1,
                "maximum": 6
              },
              "language": {
                "type": "string",
                "description": "Programming language for code blocks"
              },
              "url": {
                "type": "string",
                "format": "uri",
                "description": "URL for image or embed blocks"
              },
              "alt": {
                "type": "string",
                "description": "Alt text for image blocks"
              },
              "caption": {
                "type": "string",
                "description": "Optional caption for media blocks"
              },
              "items": {
                "type": "array",
                "description": "Items for list blocks",
                "items": {
                  "type": "string"
                }
              },
              "listType": {
                "type": "string",
                "description": "Type of list (ordered or unordered)",
                "enum": [
                  "ordered",
                  "unordered"
                ]
              }
            },
            "allOf": [
              {
                "if": {
                  "properties": {
                    "type": {
                      "const": "heading"
                    }
                  }
                },
                "then": {
                  "required": [
                    "level"
                  ]
                }
              },
              {
                "if": {
                  "properties": {
                    "type": {
                      "const": "code"
                    }
                  }
                },
                "then": {
                  "required": [
                    "language"
                  ]
                }
              },
              {
                "if": {
                  "properties": {
                    "type": {
                      "const": "image"
                    }
                  }
                },
                "then": {
                  "required": [
                    "url",
                    "alt"
                  ]
                }
              },
              {
                "if": {
                  "properties": {
                    "type": {
                      "const": "list"
                    }
                  }
                },
                "then": {
                  "required": [
                    "items",
                    "listType"
                  ]
                }
              }
            ]
          }
        }
      }
    }
  }
}
</file>

<file path="src/schema-loader.js">
/**
 * BlockDoc Schema Loader
 * 
 * Loads the JSON schema without requiring import assertions
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get current directory
const __dirname = path.dirname(fileURLToPath(import.meta.url));

// Load schema
const schemaPath = path.join(__dirname, 'schema/blockdoc.schema.json');
const schemaContent = fs.readFileSync(schemaPath, 'utf-8');
export const schema = JSON.parse(schemaContent);
</file>

<file path="tests/core/block.test.js">
/**
 * Tests for Block class
 */
import { Block } from '../../src/core/block.js';

describe('Block class', () => {
  describe('Constructor', () => {
    test('should create a valid block with required properties', () => {
      const block = new Block({
        id: 'test-block',
        type: 'text',
        content: 'Hello world'
      });

      expect(block.id).toBe('test-block');
      expect(block.type).toBe('text');
      expect(block.content).toBe('Hello world');
    });

    test('should throw error when ID is missing', () => {
      expect(() => new Block({
        type: 'text',
        content: 'Hello world'
      })).toThrow(/Block ID is required/);
    });

    test('should throw error when type is invalid', () => {
      expect(() => new Block({
        id: 'test-block',
        type: 'invalid-type',
        content: 'Hello world'
      })).toThrow(/Invalid block type/);
    });

    test('should handle empty content', () => {
      const block = new Block({
        id: 'test-block',
        type: 'text'
      });

      expect(block.content).toBe('');
    });

    test('should require type-specific properties for heading', () => {
      expect(() => new Block({
        id: 'heading-block',
        type: 'heading',
        content: 'Heading'
      })).toThrow(/requires property "level"/);

      const block = new Block({
        id: 'heading-block',
        type: 'heading',
        content: 'Heading',
        level: 2
      });

      expect(block.level).toBe(2);
    });

    test('should require type-specific properties for code', () => {
      expect(() => new Block({
        id: 'code-block',
        type: 'code',
        content: 'const x = 1;'
      })).toThrow(/requires property "language"/);

      const block = new Block({
        id: 'code-block',
        type: 'code',
        content: 'const x = 1;',
        language: 'javascript'
      });

      expect(block.language).toBe('javascript');
    });

    test('should require type-specific properties for image', () => {
      expect(() => new Block({
        id: 'image-block',
        type: 'image',
        content: ''
      })).toThrow(/requires property "url"/);

      expect(() => new Block({
        id: 'image-block',
        type: 'image',
        content: '',
        url: 'https://example.com/image.jpg'
      })).toThrow(/requires property "alt"/);

      const block = new Block({
        id: 'image-block',
        type: 'image',
        content: '',
        url: 'https://example.com/image.jpg',
        alt: 'Example image'
      });

      expect(block.url).toBe('https://example.com/image.jpg');
      expect(block.alt).toBe('Example image');
    });

    test('should require type-specific properties for list', () => {
      expect(() => new Block({
        id: 'list-block',
        type: 'list',
        content: ''
      })).toThrow(/requires property "items"/);

      expect(() => new Block({
        id: 'list-block',
        type: 'list',
        content: '',
        items: ['Item 1', 'Item 2']
      })).toThrow(/requires property "listType"/);

      const block = new Block({
        id: 'list-block',
        type: 'list',
        content: '',
        items: ['Item 1', 'Item 2'],
        listType: 'unordered'
      });

      expect(block.items).toEqual(['Item 1', 'Item 2']);
      expect(block.listType).toBe('unordered');
    });

    test('should copy additional properties', () => {
      const block = new Block({
        id: 'test-block',
        type: 'text',
        content: 'Hello world',
        customProp: 'custom value'
      });

      expect(block.customProp).toBe('custom value');
    });
  });

  describe('update()', () => {
    test('should update block properties', () => {
      const block = new Block({
        id: 'test-block',
        type: 'text',
        content: 'Hello world'
      });

      block.update({
        content: 'Updated content',
        customProp: 'custom value'
      });

      expect(block.content).toBe('Updated content');
      expect(block.customProp).toBe('custom value');
    });

    test('should not allow updating id or type', () => {
      const block = new Block({
        id: 'test-block',
        type: 'text',
        content: 'Hello world'
      });

      block.update({
        id: 'new-id',
        type: 'heading',
        content: 'Updated content'
      });

      expect(block.id).toBe('test-block');
      expect(block.type).toBe('text');
      expect(block.content).toBe('Updated content');
    });
  });

  describe('toJSON()', () => {
    test('should convert block to plain object', () => {
      const block = new Block({
        id: 'test-block',
        type: 'text',
        content: 'Hello world',
        customProp: 'custom value'
      });

      const json = block.toJSON();

      expect(json).toEqual({
        id: 'test-block',
        type: 'text',
        content: 'Hello world',
        customProp: 'custom value'
      });
    });
  });

  describe('Factory methods', () => {
    test('Block.text() should create a text block', () => {
      const block = Block.text('text-block', 'Hello world');

      expect(block.id).toBe('text-block');
      expect(block.type).toBe('text');
      expect(block.content).toBe('Hello world');
    });

    test('Block.heading() should create a heading block', () => {
      const block = Block.heading('heading-block', 2, 'Hello world');

      expect(block.id).toBe('heading-block');
      expect(block.type).toBe('heading');
      expect(block.content).toBe('Hello world');
      expect(block.level).toBe(2);
    });

    test('Block.image() should create an image block', () => {
      const block = Block.image(
        'image-block',
        'https://example.com/image.jpg',
        'Example image',
        'Image caption'
      );

      expect(block.id).toBe('image-block');
      expect(block.type).toBe('image');
      expect(block.url).toBe('https://example.com/image.jpg');
      expect(block.alt).toBe('Example image');
      expect(block.caption).toBe('Image caption');
    });

    test('Block.code() should create a code block', () => {
      const block = Block.code('code-block', 'javascript', 'const x = 1;');

      expect(block.id).toBe('code-block');
      expect(block.type).toBe('code');
      expect(block.content).toBe('const x = 1;');
      expect(block.language).toBe('javascript');
    });

    test('Block.list() should create a list block', () => {
      const items = ['Item 1', 'Item 2', 'Item 3'];
      const block = Block.list('list-block', items, 'ordered');

      expect(block.id).toBe('list-block');
      expect(block.type).toBe('list');
      expect(block.items).toEqual(items);
      expect(block.listType).toBe('ordered');
    });

    test('Block.list() should default to unordered list type', () => {
      const items = ['Item 1', 'Item 2', 'Item 3'];
      const block = Block.list('list-block', items);

      expect(block.listType).toBe('unordered');
    });
  });
});
</file>

<file path="tests/core/document.test.js">
/**
 * Tests for BlockDocDocument class
 */
import { BlockDocDocument } from '../../src/core/document.js';
import { Block } from '../../src/core/block.js';

// Mock the schema module
jest.mock('../../src/schema-loader.js', () => ({
  schema: {
    type: 'object',
    properties: {
      article: {
        type: 'object',
        properties: {
          title: { type: 'string' },
          blocks: { type: 'array' }
        }
      }
    }
  }
}));

// Mock the renderer modules
jest.mock('../../src/renderers/html.js', () => ({
  renderToHTML: jest.fn().mockReturnValue('<article>Mocked HTML</article>')
}));

jest.mock('../../src/renderers/markdown.js', () => ({
  renderToMarkdown: jest.fn().mockReturnValue('# Mocked Markdown')
}));

describe('BlockDocDocument class', () => {
  describe('Constructor', () => {
    test('should create a document with required properties', () => {
      const doc = new BlockDocDocument({
        title: 'Test Document'
      });

      expect(doc.article.title).toBe('Test Document');
      expect(doc.article.blocks).toEqual([]);
      expect(doc.article.metadata).toEqual({});
    });

    test('should create a document with metadata', () => {
      const metadata = {
        author: 'John Doe',
        publishedDate: '2023-09-22T12:00:00Z',
        tags: ['test', 'document']
      };

      const doc = new BlockDocDocument({
        title: 'Test Document',
        metadata
      });

      expect(doc.article.metadata).toEqual(metadata);
    });

    test('should create a document with initial blocks', () => {
      const blocks = [
        {
          id: 'block1',
          type: 'text',
          content: 'Hello world'
        },
        {
          id: 'block2',
          type: 'heading',
          level: 2,
          content: 'Section title'
        }
      ];

      const doc = new BlockDocDocument({
        title: 'Test Document',
        blocks
      });

      expect(doc.article.blocks.length).toBe(2);
      expect(doc.article.blocks[0].id).toBe('block1');
      expect(doc.article.blocks[1].id).toBe('block2');
    });
  });

  describe('Block operations', () => {
    let doc;

    beforeEach(() => {
      doc = new BlockDocDocument({
        title: 'Test Document'
      });
    });

    test('addBlock() should add a block to the document', () => {
      const block = doc.addBlock({
        id: 'block1',
        type: 'text',
        content: 'Hello world'
      });

      expect(block).toBeInstanceOf(Block);
      expect(doc.article.blocks.length).toBe(1);
      expect(doc.article.blocks[0].id).toBe('block1');
    });

    test('addBlock() should throw error if block ID already exists', () => {
      doc.addBlock({
        id: 'block1',
        type: 'text',
        content: 'Hello world'
      });

      expect(() => doc.addBlock({
        id: 'block1',
        type: 'heading',
        level: 2,
        content: 'Section title'
      })).toThrow(/Block with ID "block1" already exists/);
    });

    test('insertBlock() should insert a block at a specific position', () => {
      doc.addBlock({
        id: 'block1',
        type: 'text',
        content: 'Hello world'
      });

      doc.addBlock({
        id: 'block3',
        type: 'text',
        content: 'End of document'
      });

      doc.insertBlock({
        id: 'block2',
        type: 'heading',
        level: 2,
        content: 'Section title'
      }, 1);

      expect(doc.article.blocks.length).toBe(3);
      expect(doc.article.blocks[0].id).toBe('block1');
      expect(doc.article.blocks[1].id).toBe('block2');
      expect(doc.article.blocks[2].id).toBe('block3');
    });

    test('getBlock() should return block by ID', () => {
      doc.addBlock({
        id: 'block1',
        type: 'text',
        content: 'Hello world'
      });

      const block = doc.getBlock('block1');
      expect(block).toBeDefined();
      expect(block.id).toBe('block1');
    });

    test('getBlock() should return null if block not found', () => {
      const block = doc.getBlock('nonexistent');
      expect(block).toBeNull();
    });

    test('updateBlock() should update an existing block', () => {
      doc.addBlock({
        id: 'block1',
        type: 'text',
        content: 'Hello world'
      });

      const updated = doc.updateBlock('block1', {
        content: 'Updated content'
      });

      expect(updated.content).toBe('Updated content');
      expect(doc.article.blocks[0].content).toBe('Updated content');
    });

    test('updateBlock() should throw error if block not found', () => {
      expect(() => doc.updateBlock('nonexistent', {
        content: 'Updated content'
      })).toThrow(/Block with ID "nonexistent" not found/);
    });

    test('removeBlock() should remove a block by ID', () => {
      doc.addBlock({
        id: 'block1',
        type: 'text',
        content: 'Hello world'
      });

      const result = doc.removeBlock('block1');
      expect(result).toBe(true);
      expect(doc.article.blocks.length).toBe(0);
    });

    test('removeBlock() should return false if block not found', () => {
      const result = doc.removeBlock('nonexistent');
      expect(result).toBe(false);
    });

    test('moveBlock() should move a block to a new position', () => {
      doc.addBlock({
        id: 'block1',
        type: 'text',
        content: 'First block'
      });

      doc.addBlock({
        id: 'block2',
        type: 'text',
        content: 'Second block'
      });

      doc.addBlock({
        id: 'block3',
        type: 'text',
        content: 'Third block'
      });

      const result = doc.moveBlock('block3', 0);
      expect(result).toBe(true);
      expect(doc.article.blocks[0].id).toBe('block3');
      expect(doc.article.blocks[1].id).toBe('block1');
      expect(doc.article.blocks[2].id).toBe('block2');
    });

    test('moveBlock() should return false if block not found', () => {
      doc.addBlock({
        id: 'block1',
        type: 'text',
        content: 'First block'
      });

      const result = doc.moveBlock('nonexistent', 0);
      expect(result).toBe(false);
    });

    test('moveBlock() should throw error if position is invalid', () => {
      doc.addBlock({
        id: 'block1',
        type: 'text',
        content: 'First block'
      });

      expect(() => doc.moveBlock('block1', -1)).toThrow(/Invalid position/);
      expect(() => doc.moveBlock('block1', 1)).toThrow(/Invalid position/);
    });
  });

  describe('Rendering and export', () => {
    let doc;

    beforeEach(() => {
      doc = new BlockDocDocument({
        title: 'Test Document',
        blocks: [
          {
            id: 'block1',
            type: 'text',
            content: 'Hello world'
          }
        ]
      });
    });

    test('renderToHTML() should render document to HTML', () => {
      const html = doc.renderToHTML();
      expect(html).toBe('<article>Mocked HTML</article>');
    });

    test('renderToMarkdown() should render document to Markdown', () => {
      const markdown = doc.renderToMarkdown();
      expect(markdown).toBe('# Mocked Markdown');
    });

    test('toJSON() should return document as JSON object', () => {
      const json = doc.toJSON();
      expect(json).toEqual({
        article: {
          title: 'Test Document',
          metadata: {},
          blocks: [
            {
              id: 'block1',
              type: 'text',
              content: 'Hello world'
            }
          ]
        }
      });
    });

    test('toString() should return document as JSON string', () => {
      const jsonString = doc.toString();
      expect(JSON.parse(jsonString)).toEqual({
        article: {
          title: 'Test Document',
          metadata: {},
          blocks: [
            {
              id: 'block1',
              type: 'text',
              content: 'Hello world'
            }
          ]
        }
      });
    });
  });

  describe('Static methods', () => {
    test('fromJSON() should create document from JSON object', () => {
      const json = {
        article: {
          title: 'Test Document',
          metadata: {
            author: 'John Doe'
          },
          blocks: [
            {
              id: 'block1',
              type: 'text',
              content: 'Hello world'
            }
          ]
        }
      };

      const doc = BlockDocDocument.fromJSON(json);
      expect(doc).toBeInstanceOf(BlockDocDocument);
      expect(doc.article.title).toBe('Test Document');
      expect(doc.article.metadata.author).toBe('John Doe');
      expect(doc.article.blocks.length).toBe(1);
    });

    test('fromJSON() should create document from JSON string', () => {
      const jsonString = JSON.stringify({
        article: {
          title: 'Test Document',
          blocks: [
            {
              id: 'block1',
              type: 'text',
              content: 'Hello world'
            }
          ]
        }
      });

      const doc = BlockDocDocument.fromJSON(jsonString);
      expect(doc).toBeInstanceOf(BlockDocDocument);
      expect(doc.article.title).toBe('Test Document');
      expect(doc.article.blocks.length).toBe(1);
    });

    test('fromJSON() should throw error if JSON is invalid', () => {
      expect(() => BlockDocDocument.fromJSON({
        notAnArticle: {}
      })).toThrow(/missing article property/);
    });
  });

  describe('validate()', () => {
    test('should validate a valid document', () => {
      const doc = new BlockDocDocument({
        title: 'Test Document',
        blocks: [{
          id: 'block1',
          type: 'text',
          content: 'Hello world'
        }]
      });
      
      expect(doc.validate()).toBe(true);
    });
  });
});
</file>

<file path="tests/renderers/html.test.js">
/**
 * Tests for HTML renderer
 */
import { renderToHTML } from '../../src/renderers/html.js';
import { marked } from 'marked';
import hljs from 'highlight.js';

// Mock dependencies
jest.mock('marked', () => ({
  marked: {
    setOptions: jest.fn(),
    parse: jest.fn(content => `<p>${content}</p>`)
  }
}));

jest.mock('highlight.js', () => ({
  __esModule: true,
  default: {
    highlight: jest.fn().mockReturnValue({ value: '<span class="hljs-keyword">highlighted</span>' }),
    highlightAuto: jest.fn().mockReturnValue({ value: '<span class="hljs-keyword">auto-highlighted</span>' }),
    getLanguage: jest.fn(lang => lang === 'javascript')
  }
}));

jest.mock('../../src/utils/sanitize.js', () => ({
  sanitizeHtml: jest.fn(html => `sanitized:${html}`)
}));

describe('HTML Renderer', () => {
  describe('renderToHTML', () => {
    test('should throw error with invalid article structure', () => {
      expect(() => renderToHTML(null)).toThrow(/Invalid article structure/);
      expect(() => renderToHTML({})).toThrow(/Invalid article structure/);
      expect(() => renderToHTML({ blocks: 'not-an-array' })).toThrow(/Invalid article structure/);
    });

    test('should render article with title and blocks', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'block1',
            type: 'text',
            content: 'Hello world'
          },
          {
            id: 'block2',
            type: 'heading',
            level: 2,
            content: 'Section Heading'
          }
        ]
      };

      const html = renderToHTML(article);
      expect(html).toContain('<article class="blockdoc-article">');
      expect(html).toContain('<h1 class="blockdoc-title">sanitized:Test Article</h1>');
      expect(html).toContain('data-block-id="block1"');
      expect(html).toContain('data-block-id="block2"');
    });

    test('should render text block', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'text-block',
            type: 'text',
            content: 'Markdown content'
          }
        ]
      };

      renderToHTML(article);
      expect(marked.parse).toHaveBeenCalledWith('Markdown content');
    });

    test('should render heading block', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'heading-block',
            type: 'heading',
            level: 2,
            content: 'Section Heading'
          }
        ]
      };

      const html = renderToHTML(article);
      expect(html).toContain('<h2>sanitized:Section Heading</h2>');
    });

    test('should clamp heading level to valid range', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'heading-block-1',
            type: 'heading',
            level: 0,
            content: 'Too Low'
          },
          {
            id: 'heading-block-2',
            type: 'heading',
            level: 8,
            content: 'Too High'
          }
        ]
      };

      const html = renderToHTML(article);
      expect(html).toContain('<h2>sanitized:Too Low</h2>');
      expect(html).toContain('<h6>sanitized:Too High</h6>');
    });

    test('should render image block', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'image-block',
            type: 'image',
            content: '',
            url: 'https://example.com/image.jpg',
            alt: 'Example image'
          }
        ]
      };

      const html = renderToHTML(article);
      expect(html).toContain('<img src="sanitized:https://example.com/image.jpg" alt="sanitized:Example image" class="blockdoc-image" />');
    });

    test('should render image block with caption', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'image-block',
            type: 'image',
            content: '',
            url: 'https://example.com/image.jpg',
            alt: 'Example image',
            caption: 'Image caption'
          }
        ]
      };

      const html = renderToHTML(article);
      expect(html).toContain('<figure class="blockdoc-figure">');
      expect(html).toContain('<figcaption class="blockdoc-caption">sanitized:Image caption</figcaption>');
    });

    test('should render code block with syntax highlighting', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'code-block',
            type: 'code',
            content: 'const x = 1;',
            language: 'javascript'
          }
        ]
      };

      renderToHTML(article);
      expect(hljs.highlight).toHaveBeenCalledWith('const x = 1;', { language: 'javascript' });
    });

    test('should render code block with auto-detection when language is not supported', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'code-block',
            type: 'code',
            content: 'const x = 1;',
            language: 'unsupported'
          }
        ]
      };

      renderToHTML(article);
      expect(hljs.highlightAuto).toHaveBeenCalledWith('const x = 1;');
    });

    test('should handle errors in code highlighting', () => {
      hljs.highlight.mockImplementationOnce(() => {
        throw new Error('Highlighting error');
      });

      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'code-block',
            type: 'code',
            content: 'const x = 1;',
            language: 'javascript'
          }
        ]
      };

      const html = renderToHTML(article);
      expect(html).toContain('sanitized:const x = 1;');
    });

    test('should render list block', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'list-block',
            type: 'list',
            content: '',
            items: ['Item 1', 'Item 2', 'Item 3'],
            listType: 'unordered'
          }
        ]
      };

      const html = renderToHTML(article);
      expect(html).toContain('<ul class="blockdoc-list blockdoc-list-unordered">');
      expect(marked.parse).toHaveBeenCalledWith('Item 1');
      expect(marked.parse).toHaveBeenCalledWith('Item 2');
      expect(marked.parse).toHaveBeenCalledWith('Item 3');
    });

    test('should render ordered list block', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'list-block',
            type: 'list',
            content: '',
            items: ['Item 1', 'Item 2', 'Item 3'],
            listType: 'ordered'
          }
        ]
      };

      const html = renderToHTML(article);
      expect(html).toContain('<ol class="blockdoc-list blockdoc-list-ordered">');
    });

    test('should handle invalid list items', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'list-block',
            type: 'list',
            content: '',
            listType: 'unordered'
          }
        ]
      };

      const html = renderToHTML(article);
      expect(html).toContain('<p>Invalid list items</p>');
    });

    test('should render quote block', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'quote-block',
            type: 'quote',
            content: 'Quote content'
          }
        ]
      };

      const html = renderToHTML(article);
      expect(html).toContain('<blockquote class="blockdoc-quote">');
      expect(marked.parse).toHaveBeenCalledWith('Quote content');
    });

    test('should render quote block with attribution', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'quote-block',
            type: 'quote',
            content: 'Quote content',
            attribution: 'Author Name'
          }
        ]
      };

      const html = renderToHTML(article);
      expect(html).toContain('<cite class="blockdoc-attribution">sanitized:Author Name</cite>');
    });

    test('should render YouTube embed block', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'embed-block',
            type: 'embed',
            content: '',
            url: 'https://www.youtube.com/watch?v=dQw4w9WgXcQ',
            embedType: 'youtube'
          }
        ]
      };

      const html = renderToHTML(article);
      expect(html).toContain('src="https://www.youtube.com/embed/dQw4w9WgXcQ"');
    });

    test('should render YouTube embed from youtu.be URL', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'embed-block',
            type: 'embed',
            content: '',
            url: 'https://youtu.be/dQw4w9WgXcQ',
            embedType: 'youtube'
          }
        ]
      };

      const html = renderToHTML(article);
      expect(html).toContain('src="https://www.youtube.com/embed/dQw4w9WgXcQ"');
    });

    test('should handle invalid YouTube URL', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'embed-block',
            type: 'embed',
            content: '',
            url: 'https://example.com/not-a-youtube-video',
            embedType: 'youtube'
          }
        ]
      };

      const html = renderToHTML(article);
      expect(html).toContain('<p>Invalid YouTube URL</p>');
    });

    test('should render Twitter embed block', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'embed-block',
            type: 'embed',
            content: '',
            url: 'https://twitter.com/user/status/123456789',
            embedType: 'twitter'
          }
        ]
      };

      const html = renderToHTML(article);
      expect(html).toContain('<div class="blockdoc-embed blockdoc-twitter">');
      expect(html).toContain('<blockquote class="twitter-tweet">');
      expect(html).toContain('sanitized:https://twitter.com/user/status/123456789');
    });

    test('should render generic embed block', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'embed-block',
            type: 'embed',
            content: '',
            url: 'https://example.com/embed',
            embedType: 'other'
          }
        ]
      };

      const html = renderToHTML(article);
      expect(html).toContain('<div class="blockdoc-embed">');
      expect(html).toContain('src="sanitized:https://example.com/embed"');
    });

    test('should render embed block with caption', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'embed-block',
            type: 'embed',
            content: '',
            url: 'https://example.com/embed',
            embedType: 'other',
            caption: 'Embed caption'
          }
        ]
      };

      const html = renderToHTML(article);
      expect(html).toContain('<figure class="blockdoc-figure">');
      expect(html).toContain('<figcaption class="blockdoc-caption">sanitized:Embed caption</figcaption>');
    });

    test('should render divider block', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'divider-block',
            type: 'divider',
            content: ''
          }
        ]
      };

      const html = renderToHTML(article);
      expect(html).toContain('<hr class="blockdoc-divider" />');
    });

    test('should handle unknown block type', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'unknown-block',
            type: 'unknown',
            content: ''
          }
        ]
      };

      const html = renderToHTML(article);
      expect(html).toContain('<p>Unknown block type: unknown</p>');
    });
  });
});
</file>

<file path="tests/renderers/markdown.test.js">
/**
 * Tests for Markdown renderer
 */
import { renderToMarkdown } from '../../src/renderers/markdown.js';

describe('Markdown Renderer', () => {
  describe('renderToMarkdown', () => {
    test('should throw error with invalid article structure', () => {
      expect(() => renderToMarkdown(null)).toThrow(/Invalid article structure/);
      expect(() => renderToMarkdown({})).toThrow(/Invalid article structure/);
      expect(() => renderToMarkdown({ blocks: 'not-an-array' })).toThrow(/Invalid article structure/);
    });

    test('should render article with title', () => {
      const article = {
        title: 'Test Article',
        blocks: []
      };

      const markdown = renderToMarkdown(article);
      expect(markdown).toContain('# Test Article');
    });

    test('should render article with metadata', () => {
      const article = {
        title: 'Test Article',
        metadata: {
          author: 'John Doe',
          publishedDate: '2023-09-22T12:00:00Z',
          tags: ['test', 'document']
        },
        blocks: []
      };

      const markdown = renderToMarkdown(article);
      expect(markdown).toContain('> Author: John Doe');
      expect(markdown).toContain('> Published: ');
      expect(markdown).toContain('> Tags: test, document');
    });

    test('should render text block', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'text-block',
            type: 'text',
            content: 'Markdown content with **bold** and *italic*'
          }
        ]
      };

      const markdown = renderToMarkdown(article);
      expect(markdown).toContain('Markdown content with **bold** and *italic*');
    });

    test('should render heading block', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'heading-block',
            type: 'heading',
            level: 2,
            content: 'Section Heading'
          }
        ]
      };

      const markdown = renderToMarkdown(article);
      expect(markdown).toContain('## Section Heading');
    });

    test('should clamp heading level to valid range', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'heading-block-1',
            type: 'heading',
            level: 0,
            content: 'Too Low'
          },
          {
            id: 'heading-block-2',
            type: 'heading',
            level: 8,
            content: 'Too High'
          }
        ]
      };

      const markdown = renderToMarkdown(article);
      expect(markdown).toContain('# Too Low');
      expect(markdown).toContain('###### Too High');
    });

    test('should render image block', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'image-block',
            type: 'image',
            content: '',
            url: 'https://example.com/image.jpg',
            alt: 'Example image'
          }
        ]
      };

      const markdown = renderToMarkdown(article);
      expect(markdown).toContain('![Example image](https://example.com/image.jpg)');
    });

    test('should render image block with caption', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'image-block',
            type: 'image',
            content: '',
            url: 'https://example.com/image.jpg',
            alt: 'Example image',
            caption: 'Image caption'
          }
        ]
      };

      const markdown = renderToMarkdown(article);
      expect(markdown).toContain('![Example image](https://example.com/image.jpg)\n*Image caption*');
    });

    test('should render code block', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'code-block',
            type: 'code',
            content: 'const x = 1;',
            language: 'javascript'
          }
        ]
      };

      const markdown = renderToMarkdown(article);
      expect(markdown).toContain('```javascript\nconst x = 1;\n```');
    });

    test('should render code block without language', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'code-block',
            type: 'code',
            content: 'const x = 1;'
          }
        ]
      };

      const markdown = renderToMarkdown(article);
      expect(markdown).toContain('```\nconst x = 1;\n```');
    });

    test('should render unordered list block', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'list-block',
            type: 'list',
            content: '',
            items: ['Item 1', 'Item 2', 'Item 3'],
            listType: 'unordered'
          }
        ]
      };

      const markdown = renderToMarkdown(article);
      expect(markdown).toContain('- Item 1\n- Item 2\n- Item 3');
    });

    test('should render ordered list block', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'list-block',
            type: 'list',
            content: '',
            items: ['Item 1', 'Item 2', 'Item 3'],
            listType: 'ordered'
          }
        ]
      };

      const markdown = renderToMarkdown(article);
      expect(markdown).toContain('1. Item 1\n2. Item 2\n3. Item 3');
    });

    test('should handle invalid list items', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'list-block',
            type: 'list',
            content: '',
            listType: 'unordered'
          }
        ]
      };

      const markdown = renderToMarkdown(article);
      expect(markdown).toContain('[Invalid list items]');
    });

    test('should render quote block', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'quote-block',
            type: 'quote',
            content: 'Quote content'
          }
        ]
      };

      const markdown = renderToMarkdown(article);
      expect(markdown).toContain('> Quote content');
    });

    test('should render quote block with attribution', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'quote-block',
            type: 'quote',
            content: 'Quote content',
            attribution: 'Author Name'
          }
        ]
      };

      const markdown = renderToMarkdown(article);
      expect(markdown).toContain('> Quote content');
      expect(markdown).toContain('Author Name');
    });

    test('should render multiline quote block', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'quote-block',
            type: 'quote',
            content: 'Quote line 1\nQuote line 2'
          }
        ]
      };

      const markdown = renderToMarkdown(article);
      expect(markdown).toContain('> Quote line 1\n> Quote line 2');
    });

    test('should render embed block', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'embed-block',
            type: 'embed',
            content: '',
            url: 'https://example.com/embed',
            embedType: 'youtube'
          }
        ]
      };

      const markdown = renderToMarkdown(article);
      expect(markdown).toContain('[youtube: https://example.com/embed](https://example.com/embed)');
    });

    test('should render embed block with caption', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'embed-block',
            type: 'embed',
            content: '',
            url: 'https://example.com/embed',
            embedType: 'youtube',
            caption: 'Embed caption'
          }
        ]
      };

      const markdown = renderToMarkdown(article);
      expect(markdown).toContain('*Embed caption*');
    });

    test('should render divider block', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'divider-block',
            type: 'divider',
            content: ''
          }
        ]
      };

      const markdown = renderToMarkdown(article);
      expect(markdown).toContain('---');
    });

    test('should handle unknown block type', () => {
      const article = {
        title: 'Test Article',
        blocks: [
          {
            id: 'unknown-block',
            type: 'unknown',
            content: ''
          }
        ]
      };

      const markdown = renderToMarkdown(article);
      expect(markdown).toContain('[Unknown block type: unknown]');
    });
  });
});
</file>

<file path="tests/utils/sanitize.test.js">
/**
 * Tests for HTML sanitization utilities
 */
import { sanitizeHtml, sanitizeUrl } from '../../src/utils/sanitize.js';

describe('HTML Sanitization', () => {
  describe('sanitizeHtml', () => {
    test('should escape HTML special characters', () => {
      const input = '<script>alert("XSS");</script>';
      const expected = '&lt;script&gt;alert(&quot;XSS&quot;);&lt;/script&gt;';
      expect(sanitizeHtml(input)).toBe(expected);
    });

    test('should handle empty input', () => {
      expect(sanitizeHtml('')).toBe('');
      expect(sanitizeHtml(null)).toBe('');
      expect(sanitizeHtml(undefined)).toBe('');
    });

    test('should preserve normal text', () => {
      const input = 'Hello world!';
      expect(sanitizeHtml(input)).toBe(input);
    });

    test('should convert non-string input to string', () => {
      expect(sanitizeHtml(123)).toBe('123');
      expect(sanitizeHtml(true)).toBe('true');
    });

    test('should escape all special characters', () => {
      const input = '<div class="test" data-attr=\'value\'>Hello & goodbye</div>';
      const expected = '&lt;div class=&quot;test&quot; data-attr=&#039;value&#039;&gt;Hello &amp; goodbye&lt;/div&gt;';
      expect(sanitizeHtml(input)).toBe(expected);
    });
  });

  describe('sanitizeUrl', () => {
    test('should allow http URLs', () => {
      const url = 'http://example.com';
      expect(sanitizeUrl(url)).toBe(url);
    });

    test('should allow https URLs', () => {
      const url = 'https://example.com';
      expect(sanitizeUrl(url)).toBe(url);
    });

    test('should convert protocol-relative URLs to https', () => {
      const url = '//example.com/page';
      expect(sanitizeUrl(url)).toBe('https://example.com/page');
    });

    test('should allow relative URLs', () => {
      const url = '/path/to/resource';
      expect(sanitizeUrl(url)).toBe(url);
    });

    test('should reject javascript URLs', () => {
      const url = 'javascript:alert("XSS")';
      expect(sanitizeUrl(url)).toBe('');
    });

    test('should reject data URLs', () => {
      const url = 'data:text/html,<script>alert("XSS")</script>';
      expect(sanitizeUrl(url)).toBe('');
    });

    test('should handle empty input', () => {
      expect(sanitizeUrl('')).toBe('');
      expect(sanitizeUrl(null)).toBe('');
      expect(sanitizeUrl(undefined)).toBe('');
    });
  });
});
</file>

<file path="tests/integration.test.js">
/**
 * Integration tests for BlockDoc library
 */
import { Block, BlockDocDocument } from '../src/index.js';

// Mock the schema module and renderers
jest.mock('../src/schema-loader.js', () => ({
  schema: {
    type: 'object',
    properties: {
      article: {
        type: 'object',
        properties: {
          title: { type: 'string' },
          blocks: { type: 'array' }
        }
      }
    }
  }
}));

jest.mock('../src/renderers/html.js', () => ({
  renderToHTML: jest.fn().mockReturnValue('<article>Mocked HTML</article>')
}));

jest.mock('../src/renderers/markdown.js', () => ({
  renderToMarkdown: jest.fn().mockReturnValue('# Mocked Markdown')
}));

describe('BlockDoc Integration Tests', () => {
  test('should create a document with multiple block types', () => {
    // Create a document
    const doc = new BlockDocDocument({
      title: 'Test Integration Document',
      metadata: {
        author: 'Test Author',
        publishedDate: new Date().toISOString(),
        tags: ['test', 'integration']
      }
    });

    // Add various block types
    doc.addBlock(Block.heading('heading1', 1, 'Main Heading'));
    doc.addBlock(Block.text('intro', 'This is an *introduction* paragraph with **bold** text.'));
    doc.addBlock(Block.heading('heading2', 2, 'Section Heading'));
    doc.addBlock(Block.list('list1', [
      'Item one',
      'Item two',
      'Item three'
    ], 'unordered'));
    doc.addBlock(Block.code('code1', 'javascript', 'function test() {\n  return true;\n}'));
    doc.addBlock(Block.image('image1', 'https://example.com/image.jpg', 'Example image', 'Example caption'));
    doc.addBlock(Block.text('conclusion', 'This is a conclusion paragraph.'));

    // Verify document structure
    expect(doc.article.blocks.length).toBe(7);
    expect(doc.article.blocks[0].type).toBe('heading');
    expect(doc.article.blocks[1].type).toBe('text');
    expect(doc.article.blocks[2].type).toBe('heading');
    expect(doc.article.blocks[3].type).toBe('list');
    expect(doc.article.blocks[4].type).toBe('code');
    expect(doc.article.blocks[5].type).toBe('image');
    expect(doc.article.blocks[6].type).toBe('text');

    // Verify specific block data
    expect(doc.article.blocks[0].level).toBe(1);
    expect(doc.article.blocks[0].content).toBe('Main Heading');
    expect(doc.article.blocks[3].items.length).toBe(3);
    expect(doc.article.blocks[4].language).toBe('javascript');
    expect(doc.article.blocks[5].url).toBe('https://example.com/image.jpg');
    expect(doc.article.blocks[5].caption).toBe('Example caption');
    
    // Verify JSON serialization and deserialization
    const jsonData = doc.toJSON();
    const recreatedDoc = BlockDocDocument.fromJSON(jsonData);
    
    expect(recreatedDoc.article.title).toBe('Test Integration Document');
    expect(recreatedDoc.article.blocks.length).toBe(7);
    expect(recreatedDoc.article.blocks[0].content).toBe('Main Heading');
    
    // Verify document manipulation
    doc.updateBlock('heading2', { content: 'Updated Section Heading' });
    expect(doc.getBlock('heading2').content).toBe('Updated Section Heading');
    
    doc.removeBlock('list1');
    expect(doc.article.blocks.length).toBe(6);
    expect(doc.getBlock('list1')).toBeNull();
    
    doc.moveBlock('conclusion', 0);
    expect(doc.article.blocks[0].id).toBe('conclusion');
  });
  
  test('should build a simple article and convert to different formats', () => {
    // Create a document
    const doc = new BlockDocDocument({
      title: 'Simple Article'
    });
    
    doc.addBlock(Block.text('intro', 'Introduction text.'));
    doc.addBlock(Block.text('body', 'Body text.'));
    doc.addBlock(Block.text('conclusion', 'Conclusion text.'));
    
    // Get JSON representation
    const json = doc.toJSON();
    expect(json).toHaveProperty('article');
    expect(json.article.title).toBe('Simple Article');
    expect(json.article.blocks.length).toBe(3);
    
    // Get string representation
    const jsonString = doc.toString();
    expect(typeof jsonString).toBe('string');
    expect(JSON.parse(jsonString)).toEqual(json);
    
    // Test HTML and Markdown rendering (mocked)
    doc.renderToHTML();
    doc.renderToMarkdown();
  });
});
</file>

<file path=".babelrc">
{
  "presets": [
    [
      "@babel/preset-env",
      {
        "targets": {
          "node": "current"
        }
      }
    ]
  ],
  "plugins": []
}
</file>

<file path=".eslintrc.json">
{
  "env": {
    "browser": true,
    "es2021": true,
    "node": true,
    "jest": true
  },
  "extends": "eslint:recommended",
  "parserOptions": {
    "ecmaVersion": "latest",
    "sourceType": "module"
  },
  "rules": {
    "indent": ["error", 2],
    "linebreak-style": ["error", "unix"],
    "quotes": ["error", "single"],
    "semi": ["error", "always"],
    "no-unused-vars": ["warn"]
  }
}
</file>

<file path="CONTRIBUTING.md">
# Contributing to BlockDoc

Thank you for considering contributing to BlockDoc! This document outlines the process for contributing to the project and provides guidelines for writing tests.

## Getting Started

1. Fork the repository
2. Clone your fork locally
3. Install dependencies with `npm install`
4. Run tests with `npm test`

## Code Style

Please follow the existing code style in the project:
- Use ES Modules (type: "module" in package.json)
- Follow JavaScript standard practices
- Include JSDoc comments for public API methods

## Development Workflow

1. Create a feature branch from `main`
2. Implement your changes
3. Add tests for new functionality
4. Ensure all tests pass with `npm test`
5. Submit a pull request

## Testing Guidelines

BlockDoc uses Jest for testing. When adding or modifying code, please follow these testing guidelines:

### Test Structure

- Tests should be placed in the `/tests` directory
- The test file structure should match the source file structure
- Use descriptive test names that explain what is being tested

### Testing Components

#### Block Tests (`/tests/core/block.test.js`)
- Test block creation with different types
- Test block validation
- Test update methods
- Test JSON conversion
- Test factory methods

#### Document Tests (`/tests/core/document.test.js`)
- Test document initialization
- Test block operations (add, update, remove, move)
- Test rendering
- Test serialization
- Test schema validation

#### Renderer Tests (`/tests/renderers/*.test.js`)
- Test rendering of all block types
- Test edge cases and error conditions
- Verify output formatting

#### Utility Tests (`/tests/utils/*.test.js`)
- Test utility functions
- Test security-related functionality

#### Integration Tests (`/tests/integration.test.js`)
- Test end-to-end workflows
- Verify components work together correctly

### Testing Best Practices

1. **Test Isolation**: Each test should be independent and not rely on the state from other tests.
2. **Mock Dependencies**: Use Jest's mocking capabilities to isolate components.
3. **Test Edge Cases**: Include tests for error conditions and boundary cases.
4. **Descriptive Test Names**: Use descriptive names like `it('should validate block type')`.
5. **Coverage**: Aim for high code coverage. Run `npm test -- --coverage` to see coverage reports.

### Example Test

```javascript
import { Block } from '../../src/core/block.js';

describe('Block', () => {
  describe('constructor', () => {
    it('should create a valid text block', () => {
      const block = new Block({
        id: 'block1',
        type: 'text',
        content: { text: 'Hello World' }
      });
      
      expect(block.id).toBe('block1');
      expect(block.type).toBe('text');
      expect(block.content.text).toBe('Hello World');
    });
    
    it('should throw error for invalid block type', () => {
      expect(() => {
        new Block({
          id: 'block1',
          type: 'invalid-type',
          content: {}
        });
      }).toThrow();
    });
  });
});
```

## Pull Request Process

1. Update documentation if needed
2. Make sure all tests pass
3. Ensure code coverage remains high
4. Request review from maintainers

## License

By contributing to BlockDoc, you agree that your contributions will be licensed under the project's license.
</file>

<file path="index.d.ts">
// Type definitions for blockdoc
// TypeScript Version: 4.5

export interface BlockData {
  id: string;
  type: string;
  content?: string;
  [key: string]: any;
}

export class Block {
  id: string;
  type: string;
  content: string;
  [key: string]: any;

  constructor(data: BlockData);
  update(updates: Partial<BlockData>): Block;
  toJSON(): BlockData;

  static text(id: string, content: string): Block;
  static heading(id: string, level: number, content: string): Block;
  static image(id: string, url: string, alt: string, caption?: string): Block;
  static code(id: string, language: string, content: string): Block;
  static list(id: string, items: string[], listType?: 'ordered' | 'unordered'): Block;
}

export interface BlockDocOptions {
  title: string;
  metadata?: Record<string, any>;
  blocks?: BlockData[];
}

export interface Article {
  title: string;
  metadata: Record<string, any>;
  blocks: BlockData[];
}

export class BlockDocDocument {
  article: Article;

  constructor(options: BlockDocOptions);
  validate(): boolean;
  addBlock(blockData: BlockData | Block): Block;
  insertBlock(blockData: BlockData | Block, position: number): Block;
  getBlock(id: string): BlockData | null;
  updateBlock(id: string, updates: Partial<BlockData>): BlockData;
  removeBlock(id: string): boolean;
  moveBlock(id: string, newPosition: number): boolean;
  renderToHTML(): string;
  renderToMarkdown(): string;
  toJSON(): { article: Article };
  toString(): string;

  static fromJSON(json: string | { article: Article }): BlockDocDocument;
}

export function renderToHTML(article: Article): string;
export function renderToMarkdown(article: Article): string;

export const schema: any;
export const version: string;

// Submodule exports
declare module 'blockdoc/renderers/html' {
  export function renderToHTML(article: Article): string;
}

declare module 'blockdoc/renderers/markdown' {
  export function renderToMarkdown(article: Article): string;
}

declare module 'blockdoc/utils/sanitize' {
  export function sanitizeHtml(html: string): string;
  export function sanitizeUrl(url: string): string;
}
</file>

<file path="jest.config.js">
export default {
  moduleNameMapper: {
    '^(\\.{1,2}/.*)\\.js$': '$1'
  },
  testEnvironment: 'node',
  verbose: true,
  collectCoverage: true,
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov'],
  testMatch: ['**/tests/**/*.test.js'],
  transform: {
    '^.+\\.jsx?$': 'babel-jest'
  }
};
</file>

<file path="NPM_PUBLICATION.md">
# Publishing BlockDoc to npm

This document provides instructions for publishing the BlockDoc package to npm.

## Prerequisites

- npm account with access to publish to the `blockdoc` package name
- Two-factor authentication (2FA) set up for your npm account
- Authenticator app accessible to generate one-time passwords (OTP)

## Publication Steps

1. Ensure all tests pass and the build is successful:

```bash
npm run lint && npm test && npm run build
```

2. Create a tarball for local testing:

```bash
npm pack
```

3. Test the package locally (in a separate test project):

```bash
# In a test project directory
npm install /path/to/blockdoc-1.0.0.tgz
```

4. Publish to npm with OTP:

```bash
# Get the OTP from your authenticator app
npm publish --otp=YOUR_OTP_CODE
```

5. Verify the package is published:

```bash
npm view blockdoc
```

6. Push git tags to GitHub:

```bash
git push origin v1.0.0
```

7. Create a GitHub release based on the tag (can be done through the GitHub web interface).

## If OTP Fails

If the OTP code fails or times out:

1. Generate a new OTP from your authenticator app
2. Try publishing again with the new OTP:

```bash
npm publish --otp=NEW_OTP_CODE
```

## Post-Publication

After successful publication:

1. Update the main README.md with installation instructions pointing to the npm package
2. Share the package with potential users
3. Consider setting up badges for npm version, license, and build status on the README

## Future Releases

For future releases:

1. Update the version in package.json
2. Update any relevant documentation
3. Run tests and build
4. Create a git tag for the new version
5. Publish to npm following the steps above
</file>

<file path="rollup.config.esm.js">
import resolve from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import babel from '@rollup/plugin-babel';
import json from '@rollup/plugin-json';
import { readdirSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));

// Function to get all js files from src directory recursively
function getSrcFiles(dir) {
  const srcPath = join(__dirname, dir);
  let files = [];
  
  readdirSync(srcPath, { withFileTypes: true }).forEach(dirent => {
    const fullPath = join(dir, dirent.name);
    
    if (dirent.isDirectory()) {
      files = files.concat(getSrcFiles(fullPath));
    } else if (dirent.name.endsWith('.js') && !dirent.name.includes('.test.js')) {
      // Only include .js files, not test files
      files.push(fullPath);
    }
  });
  
  return files;
}

// Get all source files
const srcFiles = getSrcFiles('src');

// Create config for each source file to maintain directory structure
export default srcFiles.map(file => {
  const input = file;
  // Remove 'src/' from the file path and use the rest as output path
  const outputFile = file.replace('src/', '');
  
  return {
    input,
    output: {
      file: `dist/esm/${outputFile}`,
      format: 'esm',
      sourcemap: true
    },
    plugins: [
      resolve({
        extensions: ['.js', '.json'],
        preferBuiltins: true
      }),
      json(),
      commonjs(),
      babel({
        babelHelpers: 'bundled',
        exclude: 'node_modules/**',
        presets: [
          ['@babel/preset-env', { targets: { node: '18' }, modules: false }]
        ]
      })
    ],
    external: ['ajv', 'ajv-formats', 'marked', 'highlight.js']
  };
});
</file>

<file path="rollup.config.js">
import resolve from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import babel from '@rollup/plugin-babel';
import json from '@rollup/plugin-json';

export default {
  input: 'src/index.js',
  output: {
    file: 'dist/blockdoc.js',
    format: 'esm',
    sourcemap: true
  },
  plugins: [
    resolve({
      extensions: ['.js', '.json']
    }),
    json(),
    commonjs(),
    babel({
      babelHelpers: 'bundled',
      exclude: 'node_modules/**'
    })
  ],
  external: ['ajv', 'ajv-formats', 'marked', 'highlight.js']
};
</file>

<file path="rollup.config.umd.js">
import resolve from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import babel from '@rollup/plugin-babel';
import json from '@rollup/plugin-json';
import terser from '@rollup/plugin-terser';

export default [
  // Standard UMD build
  {
    input: 'src/index.js',
    output: {
      file: 'dist/blockdoc.js',
      format: 'umd',
      name: 'BlockDoc',
      sourcemap: true,
      globals: {
        ajv: 'Ajv',
        'ajv-formats': 'AjvFormats',
        marked: 'marked',
        'highlight.js': 'hljs'
      }
    },
    plugins: [
      resolve({
        browser: true,
        extensions: ['.js', '.json']
      }),
      json(),
      commonjs(),
      babel({
        babelHelpers: 'bundled',
        exclude: 'node_modules/**',
        presets: [
          ['@babel/preset-env', { 
            targets: '> 0.25%, not dead',
            modules: false,
            useBuiltIns: 'usage',
            corejs: 3
          }]
        ]
      })
    ],
    external: ['ajv', 'ajv-formats', 'marked', 'highlight.js']
  },
  // Minified UMD build
  {
    input: 'src/index.js',
    output: {
      file: 'dist/blockdoc.min.js',
      format: 'umd',
      name: 'BlockDoc',
      sourcemap: true,
      globals: {
        ajv: 'Ajv',
        'ajv-formats': 'AjvFormats',
        marked: 'marked',
        'highlight.js': 'hljs'
      }
    },
    plugins: [
      resolve({
        browser: true,
        extensions: ['.js', '.json']
      }),
      json(),
      commonjs(),
      babel({
        babelHelpers: 'bundled',
        exclude: 'node_modules/**',
        presets: [
          ['@babel/preset-env', { 
            targets: '> 0.25%, not dead',
            modules: false,
            useBuiltIns: 'usage',
            corejs: 3
          }]
        ]
      }),
      terser()
    ],
    external: ['ajv', 'ajv-formats', 'marked', 'highlight.js']
  }
];
</file>

<file path="docs/spec/blockdoc-specification.md">
# BlockDoc Specification

Version: 1.0.0  
Status: Draft  
Date: March 23, 2025

## Overview

BlockDoc is a lightweight, structured format for content that is optimized for:

1. Human readability and editability
2. LLM (Large Language Model) generation and manipulation
3. Programmatic rendering and transformation
4. Storage in databases (relational or document-based)

This specification defines the structure and behavior of BlockDoc documents.

## Core Concepts

### Document Structure

A BlockDoc document is a JSON object with a single root property `article`, which contains:

- A `title` (string)
- An optional `metadata` object
- A `blocks` array containing content blocks

```json
{
  "article": {
    "title": "Example Article",
    "metadata": {
      "author": "Jane Smith",
      "publishedDate": "2025-03-20T12:00:00Z"
    },
    "blocks": [
      // Content blocks go here
    ]
  }
}
```

### Blocks

Each block represents a single content unit and has the following required properties:

- `id`: A unique, semantic identifier (string)
- `type`: The block type (string, from predefined set)
- `content`: The primary content of the block (string, interpreted based on type)

Additional properties may be required or optional depending on the block type.

### Block Types

#### Text Block

A text block represents a paragraph of text content, formatted using Markdown.

```json
{
  "id": "intro",
  "type": "text",
  "content": "This is a paragraph with **bold** and *italic* text."
}
```

#### Heading Block

A heading block represents a section heading.

```json
{
  "id": "section-1",
  "type": "heading",
  "level": 2,
  "content": "Section Heading"
}
```

Required properties:

- `level`: Integer from 1-6 indicating heading level

#### Image Block

An image block embeds an image.

```json
{
  "id": "hero-image",
  "type": "image",
  "url": "https://example.com/image.jpg",
  "alt": "Description of image",
  "caption": "Optional caption text"
}
```

Required properties:

- `url`: Image URL
- `alt`: Alternative text description

Optional properties:

- `caption`: Image caption

#### Code Block

A code block contains programming code with syntax highlighting.

```json
{
  "id": "example-code",
  "type": "code",
  "language": "javascript",
  "content": "function hello() {\n  console.log('Hello world');\n}"
}
```

Required properties:

- `language`: Programming language identifier

#### List Block

A list block contains a series of items.

```json
{
  "id": "key-points",
  "type": "list",
  "listType": "unordered",
  "items": ["First item", "Second item with **bold** text", "Third item"]
}
```

Required properties:

- `listType`: Either "ordered" or "unordered"
- `items`: Array of strings (may contain markdown)

#### Quote Block

A quote block represents a quotation.

```json
{
  "id": "famous-quote",
  "type": "quote",
  "content": "The unexamined life is not worth living.",
  "attribution": "Socrates"
}
```

Optional properties:

- `attribution`: Source of the quote

#### Embed Block

An embed block incorporates external content.

```json
{
  "id": "demo-video",
  "type": "embed",
  "url": "https://www.youtube.com/watch?v=dQw4w9WgXcQ",
  "embedType": "youtube",
  "caption": "Demo video"
}
```

Required properties:

- `url`: URL of the embedded content
- `embedType`: Type of embed (e.g., "youtube", "twitter", "generic")

Optional properties:

- `caption`: Caption for the embedded content

#### Divider Block

A divider block creates a horizontal rule/separator.

```json
{
  "id": "section-break",
  "type": "divider",
  "content": ""
}
```

## Best Practices

### Block IDs

Block IDs should be:

1. Unique within the document
2. Meaningful and semantic (e.g., "intro", "section-1-overview", "conclusion")
3. Machine and human-readable
4. URL-safe (using only alphanumeric characters, hyphens, and underscores)

Good: `"id": "key-findings"`  
Avoid: `"id": "block-7"` or `"id": "b172ae4f"`

### Markdown Use

When using Markdown in text blocks:

1. Use standard CommonMark syntax
2. Avoid HTML within Markdown when possible
3. Keep links accessible with descriptive text

### LLM Integration

When using BlockDoc with LLMs:

1. Use clear, semantic block IDs that describe content purpose
2. Organize content in a logical hierarchy (intro → sections → conclusion)
3. Use specific prompts when requesting block updates, referencing blocks by ID

## Extensions

The BlockDoc format can be extended with custom block types. Custom types should:

1. Follow the same base structure (id, type, content)
2. Use a prefix for the type name to avoid collisions (e.g., "myapp-gallery")
3. Document their specific properties and rendering behavior

## Use Cases

BlockDoc is particularly well-suited for:

- Modern CMS platforms
- Blog systems with structured content
- Documentation sites
- LLM-assisted content creation tools
- Interactive editing environments
- Content that requires targeted updates

## Comparison to Other Formats

BlockDoc sits between simple formats like Markdown and complex formats like Portable Text:

| Format | Structure | LLM Compatibility | Database Storage | Targeted Updates |
|--------|-----------|-------------------|------------------|------------------|
| Plain Markdown | Flat, minimal | Good | Poor | Difficult |
| BlockDoc | Flat, block-based | Excellent | Excellent | Excellent |
| Portable Text | Nested, complex | Fair | Good | Fair |
| HTML | Nested, tag-based | Poor | Poor | Difficult |

Advantages of BlockDoc:
- More structure than plain Markdown
- Less complexity than deeply nested document models
- Better LLM compatibility than most alternatives
- Simple integration with databases
- Easier targeted updates than monolithic formats

## Version History

- 1.0.0 (2025-03-23): Initial specification

## License

This specification is licensed under MIT License.
</file>

<file path="examples/llm-integration/llm-integration-example.js">
/**
 * BlockDoc LLM Integration Example
 *
 * This example demonstrates how to use BlockDoc with an LLM to:
 * 1. Generate a complete article
 * 2. Update specific sections of an article
 * 3. Extract structured information from article content
 */

import { BlockDocDocument } from "../../src/core/document.js"
import OpenAI from "openai"

// Initialize OpenAI client
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
})

/**
 * Generate a complete article using an LLM
 * @param {string} topic - Article topic
 * @param {Array<string>} sectionTitles - Section titles to include
 * @returns {Promise<BlockDocDocument>} Generated document
 */
async function generateArticle(topic, sectionTitles) {
  console.log(
    `Generating article about "${topic}" with sections: ${sectionTitles.join(
      ", "
    )}`
  )

  // Create system prompt for structuring the content
  const systemPrompt = `
    You are an expert content creator. Generate a blog article about "${topic}" with the following structure:
    
    1. An introduction block with ID "intro"
    2. The following sections, each with a heading and content paragraph:
       ${sectionTitles
         .map(
           (title, index) =>
             `- Section with ID "section-${index + 1}" and heading "${title}"`
         )
         .join("\n       ")}
    3. A conclusion block with ID "conclusion"
    
    Format your response as a JSON object matching this exact structure:
    {
      "article": {
        "title": "The article title",
        "blocks": [
          {
            "id": "intro",
            "type": "text",
            "content": "Introduction paragraph with markdown formatting"
          },
          {
            "id": "section-1",
            "type": "heading",
            "level": 2,
            "content": "First Section Title"
          },
          {
            "id": "section-1-content",
            "type": "text",
            "content": "Content for the first section with markdown"
          },
          ...and so on for each section...
          {
            "id": "conclusion",
            "type": "text",
            "content": "Conclusion paragraph"
          }
        ]
      }
    }
    
    Use markdown formatting in text blocks where appropriate.
  `

  // Generate content using the LLM
  const response = await openai.chat.completions.create({
    model: "gpt-4",
    messages: [
      {
        role: "system",
        content: systemPrompt,
      },
    ],
    temperature: 0.7,
    response_format: { type: "json_object" },
  })

  // Parse the response
  try {
    const generatedContent = JSON.parse(response.choices[0].message.content)
    return BlockDocDocument.fromJSON(generatedContent)
  } catch (error) {
    console.error("Failed to parse LLM response:", error)
    throw new Error("Failed to generate article")
  }
}

/**
 * Update a specific block in an article
 * @param {BlockDocDocument} document - The document to update
 * @param {string} blockId - ID of the block to update
 * @param {string} updatePrompt - Instructions for updating the block
 * @returns {Promise<BlockDocDocument>} Updated document
 */
async function updateBlock(document, blockId, updatePrompt) {
  // Get the current block content
  const block = document.getBlock(blockId)

  if (!block) {
    throw new Error(`Block with ID "${blockId}" not found`)
  }

  console.log(
    `Updating block "${blockId}" (${block.type}) with prompt: "${updatePrompt}"`
  )

  // Create a prompt for updating the content
  const systemPrompt = `
    You are helping to update part of a blog article. 
    You will be given the current content of a block and instructions for updating it.
    
    Current block (${block.type}): 
    ${block.content}
    
    Update instructions: ${updatePrompt}
    
    Respond with ONLY the updated content for this block. Maintain the same style, tone, and format.
    If the block is a heading, keep it concise and clear. If it's a text block, use appropriate markdown formatting.
  `

  // Generate updated content
  const response = await openai.chat.completions.create({
    model: "gpt-4",
    messages: [
      {
        role: "system",
        content: systemPrompt,
      },
    ],
    temperature: 0.5,
  })

  // Update the block with new content
  const updatedContent = response.choices[0].message.content.trim()
  document.updateBlock(blockId, { content: updatedContent })

  return document
}

/**
 * Extract keywords from an article
 * @param {BlockDocDocument} document - The document to analyze
 * @returns {Promise<Array<string>>} Extracted keywords
 */
async function extractKeywords(document) {
  // Combine text blocks for analysis
  const textBlocks = document.article.blocks
    .filter((block) => block.type === "text")
    .map((block) => block.content)
    .join("\n\n")

  // Create a prompt for extracting keywords
  const systemPrompt = `
    Analyze the following article content and extract 5-7 key keywords or phrases that
    best represent the main topics covered. Return ONLY a JSON array of strings.
    
    Article content:
    ${textBlocks}
  `

  // Extract keywords using the LLM
  const response = await openai.chat.completions.create({
    model: "gpt-4",
    messages: [
      {
        role: "system",
        content: systemPrompt,
      },
    ],
    temperature: 0.2,
    response_format: { type: "json_object" },
  })

  // Parse the response
  try {
    const result = JSON.parse(response.choices[0].message.content)
    return Array.isArray(result) ? result : result.keywords || []
  } catch (error) {
    console.error("Failed to parse keyword extraction response:", error)
    return []
  }
}

/**
 * Main demo function
 */
async function runDemo() {
  try {
    // 1. Generate a complete article
    const topic = "The Future of Sustainable Energy"
    const sectionTitles = [
      "Current Renewable Energy Landscape",
      "Emerging Technologies",
      "Policy Implications",
      "Economic Opportunities",
    ]

    const document = await generateArticle(topic, sectionTitles)
    console.log("\nGenerated Article:")
    console.log(document.toString())

    // 2. Update a specific section
    const updatedDocument = await updateBlock(
      document,
      "section-2-content",
      "Focus more on fusion energy and include recent breakthroughs from 2024"
    )

    console.log("\nUpdated Section:")
    console.log(updatedDocument.getBlock("section-2-content").content)

    // 3. Extract keywords
    const keywords = await extractKeywords(updatedDocument)
    console.log("\nExtracted Keywords:")
    console.log(keywords)

    // 4. Render to HTML
    console.log("\nHTML Output (preview):")
    const html = updatedDocument.renderToHTML()
    console.log(html.substring(0, 500) + "...")
  } catch (error) {
    console.error("Demo failed:", error)
  }
}

// Run the demo if this file is executed directly
if (require.main === module) {
  runDemo().then(() => console.log("Demo completed"))
}

export { generateArticle, updateBlock, extractKeywords }
</file>

<file path="src/api/client.js">
/**
 * BlockDoc API Client
 *
 * Client for interacting with a BlockDoc API server
 */

import { BlockDocDocument } from '../core/document.js';

export class BlockDocClient {
  /**
   * Create a new BlockDoc client
   * @param {string} baseUrl - API base URL
   * @param {Object} options - Client options
   * @param {Object} options.headers - Custom headers to include in requests
   */
  constructor(baseUrl, options = {}) {
    this.baseUrl = baseUrl.endsWith('/') ? baseUrl : `${baseUrl}/`;
    this.headers = {
      'Content-Type': 'application/json',
      'Accept': 'application/json',
      ...options.headers
    };
  }

  /**
   * Make an API request
   * @param {string} path - API path
   * @param {Object} options - Fetch options
   * @returns {Promise<Object>} Response data
   * @private
   */
  async _request(path, options = {}) {
    const url = `${this.baseUrl}${path}`;
    
    const response = await fetch(url, {
      headers: this.headers,
      ...options
    });
    
    if (!response.ok) {
      const error = await response.text();
      throw new Error(`API request failed: ${response.status} ${error}`);
    }
    
    // Return JSON response or null for 204 No Content
    return response.status === 204 ? null : await response.json();
  }

  /**
   * Get a document by ID
   * @param {string} documentId - Document ID
   * @returns {Promise<BlockDocDocument>} The document
   */
  async getDocument(documentId) {
    const data = await this._request(`documents/${documentId}`);
    return BlockDocDocument.fromJSON(data);
  }

  /**
   * Create a new document
   * @param {BlockDocDocument} document - The document to create
   * @returns {Promise<Object>} Creation result with ID
   */
  async createDocument(document) {
    return this._request('documents', {
      method: 'POST',
      body: JSON.stringify(document.toJSON())
    });
  }

  /**
   * Update an existing document
   * @param {string} documentId - Document ID
   * @param {BlockDocDocument} document - Updated document
   * @returns {Promise<Object>} Update result
   */
  async updateDocument(documentId, document) {
    return this._request(`documents/${documentId}`, {
      method: 'PUT',
      body: JSON.stringify(document.toJSON())
    });
  }

  /**
   * Delete a document
   * @param {string} documentId - Document ID
   * @returns {Promise<void>}
   */
  async deleteDocument(documentId) {
    await this._request(`documents/${documentId}`, {
      method: 'DELETE'
    });
  }

  /**
   * Update a specific block in a document
   * @param {string} documentId - Document ID
   * @param {string} blockId - Block ID
   * @param {Object} updates - Properties to update
   * @returns {Promise<Object>} Updated block
   */
  async updateBlock(documentId, blockId, updates) {
    return this._request(`documents/${documentId}/blocks/${blockId}`, {
      method: 'PATCH',
      body: JSON.stringify(updates)
    });
  }

  /**
   * Get a list of documents
   * @param {Object} query - Query parameters
   * @param {number} query.limit - Maximum number of documents to return
   * @param {number} query.offset - Offset for pagination
   * @returns {Promise<Array<Object>>} List of document summaries
   */
  async listDocuments(query = {}) {
    const queryParams = new URLSearchParams();
    
    if (query.limit) queryParams.append('limit', query.limit);
    if (query.offset) queryParams.append('offset', query.offset);
    
    const path = `documents${queryParams.toString() ? `?${queryParams.toString()}` : ''}`;
    return this._request(path);
  }
}
</file>

<file path="src/api/server.js">
/**
 * BlockDoc API Server
 *
 * Express middleware for creating a BlockDoc API server
 * Note: This is a minimal implementation meant for simple use cases.
 * For production, use a proper database and more robust error handling.
 */

export function createBlockDocApi(options = {}) {
  // This function returns Express middleware that handles BlockDoc API endpoints
  return function blockDocApiMiddleware(req, res, next) {
    // Skip non-matching routes
    if (!req.path.startsWith('/api/blockdoc/')) {
      return next();
    }
    
    const path = req.path.replace('/api/blockdoc/', '');
    const pathParts = path.split('/').filter(Boolean);
    
    // Route handling
    try {
      if (pathParts[0] === 'documents') {
        if (req.method === 'GET' && pathParts.length === 1) {
          // GET /api/blockdoc/documents - List documents
          return handleListDocuments(req, res, options);
        } else if (req.method === 'POST' && pathParts.length === 1) {
          // POST /api/blockdoc/documents - Create document
          return handleCreateDocument(req, res, options);
        } else if (req.method === 'GET' && pathParts.length === 2) {
          // GET /api/blockdoc/documents/:id - Get document
          return handleGetDocument(req, res, pathParts[1], options);
        } else if (req.method === 'PUT' && pathParts.length === 2) {
          // PUT /api/blockdoc/documents/:id - Update document
          return handleUpdateDocument(req, res, pathParts[1], options);
        } else if (req.method === 'DELETE' && pathParts.length === 2) {
          // DELETE /api/blockdoc/documents/:id - Delete document
          return handleDeleteDocument(req, res, pathParts[1], options);
        } else if (req.method === 'PATCH' && pathParts.length === 4 && pathParts[2] === 'blocks') {
          // PATCH /api/blockdoc/documents/:id/blocks/:blockId - Update block
          return handleUpdateBlock(req, res, pathParts[1], pathParts[3], options);
        }
      }
      
      // Render routes
      if (pathParts[0] === 'render') {
        if (req.method === 'POST' && pathParts.length === 2) {
          if (pathParts[1] === 'html') {
            // POST /api/blockdoc/render/html - Render to HTML
            return handleRenderToHTML(req, res);
          } else if (pathParts[1] === 'markdown') {
            // POST /api/blockdoc/render/markdown - Render to Markdown
            return handleRenderToMarkdown(req, res);
          }
        }
      }
      
      // No matching route
      res.status(404).json({ error: 'Not found' });
    } catch (error) {
      console.error('BlockDoc API Error:', error);
      res.status(500).json({ error: error.message || 'Internal server error' });
    }
  };
}

// Route handlers
// Note: These functions would typically interact with a database

function handleListDocuments(req, res, options) {
  const { storage = {} } = options;
  const limit = parseInt(req.query.limit) || 10;
  const offset = parseInt(req.query.offset) || 0;
  
  // In a real implementation, this would query a database
  const documents = Object.values(storage)
    .slice(offset, offset + limit)
    .map(doc => ({
      id: doc.id,
      title: doc.article.title,
      updatedAt: doc.updatedAt
    }));
  
  res.json({
    documents,
    total: Object.keys(storage).length,
    limit,
    offset
  });
}

function handleCreateDocument(req, res, options) {
  const { storage = {}, onDocumentCreated } = options;
  const document = req.body;
  
  // Validate document
  if (!document || !document.article || !document.article.title) {
    return res.status(400).json({ error: 'Invalid document format' });
  }
  
  // Generate ID if not provided
  const id = document.id || generateId();
  
  // Store document
  const storedDocument = {
    ...document,
    id,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  };
  
  storage[id] = storedDocument;
  
  // Trigger event handler if provided
  if (typeof onDocumentCreated === 'function') {
    onDocumentCreated(storedDocument);
  }
  
  res.status(201).json({ id, message: 'Document created' });
}

function handleGetDocument(req, res, documentId, options) {
  const { storage = {} } = options;
  
  if (!storage[documentId]) {
    return res.status(404).json({ error: 'Document not found' });
  }
  
  res.json(storage[documentId]);
}

function handleUpdateDocument(req, res, documentId, options) {
  const { storage = {}, onDocumentUpdated } = options;
  
  if (!storage[documentId]) {
    return res.status(404).json({ error: 'Document not found' });
  }
  
  const document = req.body;
  
  // Validate document
  if (!document || !document.article || !document.article.title) {
    return res.status(400).json({ error: 'Invalid document format' });
  }
  
  // Update document
  const updatedDocument = {
    ...document,
    id: documentId,
    createdAt: storage[documentId].createdAt,
    updatedAt: new Date().toISOString()
  };
  
  storage[documentId] = updatedDocument;
  
  // Trigger event handler if provided
  if (typeof onDocumentUpdated === 'function') {
    onDocumentUpdated(updatedDocument);
  }
  
  res.json({ message: 'Document updated' });
}

function handleDeleteDocument(req, res, documentId, options) {
  const { storage = {}, onDocumentDeleted } = options;
  
  if (!storage[documentId]) {
    return res.status(404).json({ error: 'Document not found' });
  }
  
  const deletedDocument = storage[documentId];
  delete storage[documentId];
  
  // Trigger event handler if provided
  if (typeof onDocumentDeleted === 'function') {
    onDocumentDeleted(deletedDocument);
  }
  
  res.status(204).end();
}

function handleUpdateBlock(req, res, documentId, blockId, options) {
  const { storage = {}, onBlockUpdated } = options;
  
  if (!storage[documentId]) {
    return res.status(404).json({ error: 'Document not found' });
  }
  
  const document = storage[documentId];
  const blockIndex = document.article.blocks.findIndex(block => block.id === blockId);
  
  if (blockIndex === -1) {
    return res.status(404).json({ error: 'Block not found' });
  }
  
  // Update block
  const updates = req.body;
  const block = document.article.blocks[blockIndex];
  
  // Cannot change id or type
  const { id, type, ...allowedUpdates } = updates;
  
  // Apply updates
  const updatedBlock = {
    ...block,
    ...allowedUpdates
  };
  
  document.article.blocks[blockIndex] = updatedBlock;
  document.updatedAt = new Date().toISOString();
  
  // Trigger event handler if provided
  if (typeof onBlockUpdated === 'function') {
    onBlockUpdated(document, updatedBlock);
  }
  
  res.json(updatedBlock);
}

// Render handlers
function handleRenderToHTML(req, res) {
  const { renderToHTML } = require('../renderers/html.js');
  const document = req.body;
  
  if (!document || !document.article) {
    return res.status(400).json({ error: 'Invalid document format' });
  }
  
  try {
    const html = renderToHTML(document.article);
    res.send(html);
  } catch (error) {
    res.status(400).json({ error: `Rendering failed: ${error.message}` });
  }
}

function handleRenderToMarkdown(req, res) {
  const { renderToMarkdown } = require('../renderers/markdown.js');
  const document = req.body;
  
  if (!document || !document.article) {
    return res.status(400).json({ error: 'Invalid document format' });
  }
  
  try {
    const markdown = renderToMarkdown(document.article);
    res.send(markdown);
  } catch (error) {
    res.status(400).json({ error: `Rendering failed: ${error.message}` });
  }
}

// Helper function to generate a simple ID
function generateId() {
  return `doc_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
}
</file>

<file path="src/core/block.js">
/**
 * BlockDoc Block
 *
 * Represents a single content block within a BlockDoc document
 */

// Define allowed block types
const ALLOWED_TYPES = [
  'text',
  'heading',
  'image',
  'code',
  'list',
  'quote',
  'embed',
  'divider',
];

// Define type-specific required properties
const TYPE_REQUIREMENTS = {
  heading: ['level'],
  code: ['language'],
  image: ['url', 'alt'],
  list: ['items', 'listType'],
};

export class Block {
  /**
   * Create a new block
   * @param {Object} data - Block data
   * @param {string} data.id - Unique identifier
   * @param {string} data.type - Block type
   * @param {string} data.content - Block content
   * @param {Object} [data.properties] - Additional type-specific properties
   */
  constructor(data) {
    if (!data.id) {
      throw new Error('Block ID is required');
    }

    if (!data.type || !ALLOWED_TYPES.includes(data.type)) {
      throw new Error(
        `Invalid block type: ${
          data.type
        }. Allowed types are: ${ALLOWED_TYPES.join(', ')}`
      );
    }

    // Basic properties all blocks have
    this.id = data.id;
    this.type = data.type;
    this.content = data.content || '';

    // Check type-specific required properties
    const requiredProps = TYPE_REQUIREMENTS[this.type] || [];
    for (const prop of requiredProps) {
      if (data[prop] === undefined) {
        throw new Error(
          `Block of type "${this.type}" requires property "${prop}"`
        );
      }
      this[prop] = data[prop];
    }

    // Copy any additional properties
    Object.keys(data).forEach((key) => {
      if (!['id', 'type', 'content'].includes(key) && this[key] === undefined) {
        this[key] = data[key];
      }
    });
  }

  /**
   * Update block properties
   * @param {Object} updates - Properties to update
   * @returns {Block} Updated block instance
   */
  update(updates) {
    // Cannot change block type or ID
    const { id, type, ...allowedUpdates } = updates;

    // Apply updates
    Object.keys(allowedUpdates).forEach((key) => {
      this[key] = allowedUpdates[key];
    });

    return this;
  }

  /**
   * Convert block to plain object
   * @returns {Object} Block as plain object
   */
  toJSON() {
    const result = {
      id: this.id,
      type: this.type,
      content: this.content,
    };

    // Add type-specific properties
    Object.keys(this).forEach((key) => {
      if (!['id', 'type', 'content'].includes(key)) {
        result[key] = this[key];
      }
    });

    return result;
  }

  /**
   * Create common block types with simplified APIs
   */

  /**
   * Create a text block
   * @param {string} id - Block ID
   * @param {string} content - Markdown content
   * @returns {Block} New block instance
   */
  static text(id, content) {
    return new Block({
      id,
      type: 'text',
      content,
    });
  }

  /**
   * Create a heading block
   * @param {string} id - Block ID
   * @param {number} level - Heading level (1-6)
   * @param {string} content - Heading text
   * @returns {Block} New block instance
   */
  static heading(id, level, content) {
    return new Block({
      id,
      type: 'heading',
      level,
      content,
    });
  }

  /**
   * Create an image block
   * @param {string} id - Block ID
   * @param {string} url - Image URL
   * @param {string} alt - Alt text
   * @param {string} [caption] - Optional caption
   * @returns {Block} New block instance
   */
  static image(id, url, alt, caption) {
    return new Block({
      id,
      type: 'image',
      content: '',
      url,
      alt,
      ...(caption ? { caption } : {}),
    });
  }

  /**
   * Create a code block
   * @param {string} id - Block ID
   * @param {string} language - Programming language
   * @param {string} content - Code content
   * @returns {Block} New block instance
   */
  static code(id, language, content) {
    return new Block({
      id,
      type: 'code',
      language,
      content,
    });
  }

  /**
   * Create a list block
   * @param {string} id - Block ID
   * @param {Array<string>} items - List items
   * @param {string} [listType='unordered'] - List type (ordered or unordered)
   * @returns {Block} New block instance
   */
  static list(id, items, listType = 'unordered') {
    return new Block({
      id,
      type: 'list',
      content: '',
      items,
      listType,
    });
  }
}
</file>

<file path="src/utils/sanitize.js">
/**
 * BlockDoc HTML Sanitization
 * 
 * Provides utilities for sanitizing HTML content
 */

/**
 * Simple HTML sanitizer to prevent XSS
 * @param {string} html - HTML content to sanitize
 * @returns {string} Sanitized HTML
 */
export function sanitizeHtml(html) {
  if (!html) return '';
  
  const map = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    '\'': '&#039;'
  };
  
  return String(html).replace(/[&<>"']/g, function(m) { return map[m]; });
}

/**
 * Sanitize a URL for safe embedding
 * @param {string} url - URL to sanitize
 * @returns {string} Sanitized URL
 */
export function sanitizeUrl(url) {
  if (!url) return '';
  
  // Only allow http and https protocols
  if (url.match(/^https?:\/\//i)) {
    return url;
  } else if (url.startsWith('//')) {
    return `https:${url}`;
  } else if (!url.includes(':')) {
    // Relative URLs are considered safe
    return url;
  }
  
  // Default to empty for potentially unsafe protocols
  return '';
}
</file>

<file path=".npmignore">
# Development files
.github/
.git/
.vscode/
.idea/
node_modules/
coverage/
examples/
docs/
tests/
.gitignore
.npmrc
.babelrc
.eslintrc.json
babel.config.json
rollup.config*.js
jest.config.js
jsdoc.json
tsconfig.json
CONTRIBUTING.md
CLAUDE.md
CLAUDE_CONVO.md

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# OS specific
.DS_Store
Thumbs.db
</file>

<file path="babel.config.json">
{
  "presets": [
    [
      "@babel/preset-env",
      {
        "targets": {
          "node": "18"
        },
        "modules": false
      }
    ]
  ]
}
</file>

<file path="CLAUDE.md">
# BlockDoc Project Information

## Project Overview
BlockDoc is a lightweight structured content format designed for:
- Creating modular, block-based content (similar to Notion or modern CMS systems)
- Optimizing content for LLM generation and modification
- Providing a simple flat structure with semantic IDs
- Enabling easy storage in databases
- Allowing targeted updates to specific sections
- Representing content as JSON with blocks that have IDs, types, and content

## Common Commands

### Development
```bash
# Install dependencies
npm install

# Build the project
npm run build

# Generate documentation
npm run docs

# Run linting
npm run lint

# Run examples
npm run examples
```

### Testing
```bash
# Run tests
npm test

# Run tests with coverage report
npm test -- --coverage

# Run specific test file
npm test -- tests/core/block.test.js

# Run tests in watch mode
npm test -- --watch
```

## CI/CD
The project uses GitHub Actions for continuous integration. The workflow:
- Runs on push to main/master and on pull requests
- Tests with Node.js 18.x and 20.x
- Uploads coverage reports to Codecov

## Code Style
- JavaScript ES Modules (type: "module" in package.json)
- Node.js (>= v18.0.0)

## Project Structure
- `/src/core/`: Core functionality (block.js, document.js)
- `/src/renderers/`: Output renderers (HTML, Markdown)
- `/src/api/`: API client and server components
- `/src/schema/`: JSON schema for validation
- `/docs/`: Documentation files
- `/examples/`: Example implementations and use cases
- `/tests/`: Test files
  - `/tests/core/`: Tests for core components
  - `/tests/renderers/`: Tests for renderers
  - `/tests/utils/`: Tests for utility functions
  - `/tests/integration.test.js`: Integration tests
- `/dist/`: Built distribution files
  - `/dist/cjs/`: CommonJS modules
  - `/dist/esm/`: ES modules
  - `/dist/blockdoc.js`: UMD bundle
  - `/dist/blockdoc.min.js`: Minified UMD bundle

## npm Package
The BlockDoc library is published to npm with the following features:
- Supports ESM, CommonJS, and UMD formats
- Includes TypeScript definitions
- Version: 1.0.0
- Entry points:
  - Main: ./dist/cjs/index.js (for CommonJS)
  - Module: ./dist/esm/index.js (for ESM)
  - Browser: ./dist/blockdoc.min.js (for browsers)
- Submodule exports:
  - blockdoc/renderers/html
  - blockdoc/renderers/markdown
  - blockdoc/utils/sanitize

### Publishing
```bash
# Update version in package.json and src/index.js
# Then run:
npm run build
npm publish
```
</file>

<file path="LICENSE">
The MIT License (MIT)

Copyright (c) 2025 Eric Berry <eric@berrydev.ai>

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</file>

<file path="rollup.config.cjs.js">
import resolve from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import babel from '@rollup/plugin-babel';
import json from '@rollup/plugin-json';
import { readdirSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));

// Function to get all js files from src directory recursively
function getSrcFiles(dir) {
  const srcPath = join(__dirname, dir);
  let files = [];
  
  readdirSync(srcPath, { withFileTypes: true }).forEach(dirent => {
    const fullPath = join(dir, dirent.name);
    
    if (dirent.isDirectory()) {
      files = files.concat(getSrcFiles(fullPath));
    } else if (dirent.name.endsWith('.js') && !dirent.name.includes('.test.js')) {
      // Only include .js files, not test files
      files.push(fullPath);
    }
  });
  
  return files;
}

// Get all source files
const srcFiles = getSrcFiles('src');

// Create config for each source file to maintain directory structure
export default srcFiles.map(file => {
  const input = file;
  // Remove 'src/' from the file path and use the rest as output path
  const outputFile = file.replace('src/', '');
  
  return {
    input,
    output: {
      file: `dist/cjs/${outputFile}`,
      format: 'cjs',
      sourcemap: true,
      exports: 'named'
    },
    plugins: [
      resolve({
        extensions: ['.js', '.json'],
        preferBuiltins: true
      }),
      json(),
      commonjs(),
      babel({
        babelHelpers: 'bundled',
        exclude: 'node_modules/**',
        presets: [
          ['@babel/preset-env', { targets: { node: '18' }, modules: false }]
        ]
      })
    ],
    external: ['ajv', 'ajv-formats', 'marked', 'highlight.js']
  };
});
</file>

<file path="src/core/document.js">
/**
 * BlockDoc Document
 *
 * Core class for creating, manipulating and rendering BlockDoc documents
 */

import Ajv from 'ajv';
import addFormats from 'ajv-formats';
import { schema } from '../schema-loader.js';
import { renderToHTML } from '../renderers/html.js';
import { renderToMarkdown } from '../renderers/markdown.js';
import { Block } from './block.js';

export class BlockDocDocument {
  /**
   * Create a new BlockDoc document
   * @param {Object} options - Document initialization options
   * @param {string} options.title - Document title
   * @param {Object} [options.metadata] - Optional document metadata
   * @param {Array<Object>} [options.blocks] - Initial blocks to add
   */
  constructor({ title, metadata = {}, blocks = [] }) {
    this.article = {
      title,
      metadata,
      blocks: [],
    };

    // Add initial blocks if provided
    if (blocks && Array.isArray(blocks)) {
      blocks.forEach((block) => this.addBlock(block));
    }
  }

  /**
   * Validate the document against the BlockDoc schema
   * @returns {boolean} True if valid
   * @throws {Error} If validation fails
   */
  validate() {
    const ajv = new Ajv();
    addFormats(ajv);
    const validate = ajv.compile(schema);
    const valid = validate({ article: this.article });

    if (!valid) {
      const errors = validate.errors;
      throw new Error(`Invalid BlockDoc document: ${JSON.stringify(errors)}`);
    }

    return true;
  }

  /**
   * Add a block to the document
   * @param {Object} blockData - Block data
   * @returns {Block} The created block
   */
  addBlock(blockData) {
    // Check if ID already exists
    if (this.getBlock(blockData.id)) {
      throw new Error(`Block with ID "${blockData.id}" already exists`);
    }

    const block = new Block(blockData);
    this.article.blocks.push(block.toJSON());
    return block;
  }

  /**
   * Insert a block at a specific position
   * @param {Object} blockData - Block data
   * @param {number} position - Position to insert at
   * @returns {Block} The created block
   */
  insertBlock(blockData, position) {
    // Check if ID already exists
    if (this.getBlock(blockData.id)) {
      throw new Error(`Block with ID "${blockData.id}" already exists`);
    }

    const block = new Block(blockData);
    this.article.blocks.splice(position, 0, block.toJSON());
    return block;
  }

  /**
   * Get a block by ID
   * @param {string} id - Block ID
   * @returns {Object|null} The block or null if not found
   */
  getBlock(id) {
    return this.article.blocks.find((block) => block.id === id) || null;
  }

  /**
   * Update a block by ID
   * @param {string} id - Block ID
   * @param {Object} updates - Properties to update
   * @returns {Object} The updated block
   */
  updateBlock(id, updates) {
    const index = this.article.blocks.findIndex((block) => block.id === id);

    if (index === -1) {
      throw new Error(`Block with ID "${id}" not found`);
    }

    // Create a new block with the updates
    const currentBlock = this.article.blocks[index];
    const updatedBlock = { ...currentBlock, ...updates };

    // Validate the updated block
    const block = new Block(updatedBlock);

    // Update the block in the document
    this.article.blocks[index] = block.toJSON();

    return this.article.blocks[index];
  }

  /**
   * Remove a block by ID
   * @param {string} id - Block ID
   * @returns {boolean} True if removed
   */
  removeBlock(id) {
    const index = this.article.blocks.findIndex((block) => block.id === id);

    if (index === -1) {
      return false;
    }

    this.article.blocks.splice(index, 1);
    return true;
  }

  /**
   * Move a block to a new position
   * @param {string} id - Block ID
   * @param {number} newPosition - New position
   * @returns {boolean} True if moved
   */
  moveBlock(id, newPosition) {
    const index = this.article.blocks.findIndex((block) => block.id === id);

    if (index === -1) {
      return false;
    }

    if (newPosition < 0 || newPosition >= this.article.blocks.length) {
      throw new Error(`Invalid position: ${newPosition}`);
    }

    // Remove the block from its current position
    const [block] = this.article.blocks.splice(index, 1);

    // Insert it at the new position
    this.article.blocks.splice(newPosition, 0, block);

    return true;
  }

  /**
   * Render the document to HTML
   * @returns {string} HTML representation
   */
  renderToHTML() {
    return renderToHTML(this.article);
  }

  /**
   * Render the document to Markdown
   * @returns {string} Markdown representation
   */
  renderToMarkdown() {
    return renderToMarkdown(this.article);
  }

  /**
   * Export the document as a JSON object
   * @returns {Object} Document as JSON object
   */
  toJSON() {
    return { article: this.article };
  }

  /**
   * Export the document as a JSON string
   * @returns {string} Document as JSON string
   */
  toString() {
    return JSON.stringify(this.toJSON(), null, 2);
  }

  /**
   * Create a BlockDoc document from a JSON object
   * @param {Object|string} json - JSON object or string
   * @returns {BlockDocDocument} New document instance
   */
  static fromJSON(json) {
    const data = typeof json === 'string' ? JSON.parse(json) : json;

    if (!data.article) {
      throw new Error('Invalid BlockDoc document: missing article property');
    }

    return new BlockDocDocument({
      title: data.article.title,
      metadata: data.article.metadata || {},
      blocks: data.article.blocks || [],
    });
  }
}
</file>

<file path="src/renderers/html.js">
/**
 * BlockDoc HTML Renderer
 *
 * Converts BlockDoc documents to HTML
 */

import { marked } from 'marked';
import { sanitizeHtml } from '../utils/sanitize.js';
import hljs from 'highlight.js';

// Configure marked
marked.setOptions({
  highlight: function (code, lang) {
    if (lang && hljs.getLanguage(lang)) {
      return hljs.highlight(code, { language: lang }).value;
    }
    return hljs.highlightAuto(code).value;
  },
  headerIds: true,
  mangle: false,
});

/**
 * Render a BlockDoc document to HTML
 * @param {Object} article - The article object from a BlockDoc document
 * @returns {string} HTML representation
 */
export function renderToHTML(article) {
  if (!article || !article.blocks || !Array.isArray(article.blocks)) {
    throw new Error('Invalid article structure');
  }

  const html = [
    '<article class="blockdoc-article">',
    `<h1 class="blockdoc-title">${sanitizeHtml(article.title)}</h1>`,
  ];

  // Render each block
  article.blocks.forEach((block) => {
    html.push(renderBlock(block));
  });

  html.push('</article>');

  return html.join('\n');
}

/**
 * Render a single block to HTML
 * @param {Object} block - Block data
 * @returns {string} HTML representation of the block
 */
function renderBlock(block) {
  const { id, type } = block;

  // Wrapper with block ID and type as data attributes
  const openWrapper = `<div class="blockdoc-block blockdoc-${type}" data-block-id="${id}" data-block-type="${type}">`;
  const closeWrapper = '</div>';

  let content;

  switch (type) {
  case 'text':
    content = renderTextBlock(block);
    break;
  case 'heading':
    content = renderHeadingBlock(block);
    break;
  case 'image':
    content = renderImageBlock(block);
    break;
  case 'code':
    content = renderCodeBlock(block);
    break;
  case 'list':
    content = renderListBlock(block);
    break;
  case 'quote':
    content = renderQuoteBlock(block);
    break;
  case 'embed':
    content = renderEmbedBlock(block);
    break;
  case 'divider':
    content = renderDividerBlock();
    break;
  default:
    content = `<p>Unknown block type: ${type}</p>`;
  }

  return `${openWrapper}${content}${closeWrapper}`;
}

/**
 * Render a text block
 * @param {Object} block - Block data
 * @returns {string} HTML representation
 */
function renderTextBlock(block) {
  // Use marked to convert markdown to HTML
  return marked.parse(block.content);
}

/**
 * Render a heading block
 * @param {Object} block - Block data
 * @returns {string} HTML representation
 */
function renderHeadingBlock(block) {
  const { level, content } = block;
  const validLevel = Math.min(Math.max(parseInt(level) || 2, 1), 6);

  return `<h${validLevel}>${sanitizeHtml(content)}</h${validLevel}>`;
}

/**
 * Render an image block
 * @param {Object} block - Block data
 * @returns {string} HTML representation
 */
function renderImageBlock(block) {
  const { url, alt, caption } = block;

  let html = `<img src="${sanitizeHtml(url)}" alt="${sanitizeHtml(
    alt
  )}" class="blockdoc-image" />`;

  if (caption) {
    html += `<figcaption class="blockdoc-caption">${sanitizeHtml(
      caption
    )}</figcaption>`;
    return `<figure class="blockdoc-figure">${html}</figure>`;
  }

  return html;
}

/**
 * Render a code block
 * @param {Object} block - Block data
 * @returns {string} HTML representation
 */
function renderCodeBlock(block) {
  const { language, content } = block;

  // Use highlight.js for syntax highlighting
  let highlightedCode;

  try {
    if (language && hljs.getLanguage(language)) {
      highlightedCode = hljs.highlight(content, { language }).value;
    } else {
      highlightedCode = hljs.highlightAuto(content).value;
    }
  } catch (e) {
    highlightedCode = sanitizeHtml(content);
  }

  return `
    <pre class="blockdoc-pre">
      <code class="blockdoc-code ${
  language ? `language-${language}` : ''
}">${highlightedCode}</code>
    </pre>
  `;
}

/**
 * Render a list block
 * @param {Object} block - Block data
 * @returns {string} HTML representation
 */
function renderListBlock(block) {
  const { items, listType } = block;

  if (!items || !Array.isArray(items)) {
    return '<p>Invalid list items</p>';
  }

  const tag = listType === 'ordered' ? 'ol' : 'ul';

  const itemsHtml = items
    .map((item) => `<li>${marked.parse(item)}</li>`)
    .join('');

  return `<${tag} class="blockdoc-list blockdoc-list-${listType}">${itemsHtml}</${tag}>`;
}

/**
 * Render a quote block
 * @param {Object} block - Block data
 * @returns {string} HTML representation
 */
function renderQuoteBlock(block) {
  const { content, attribution } = block;

  let html = `<blockquote class="blockdoc-quote">${marked.parse(
    content
  )}</blockquote>`;

  if (attribution) {
    html += `<cite class="blockdoc-attribution">${sanitizeHtml(
      attribution
    )}</cite>`;
  }

  return html;
}

/**
 * Render an embed block
 * @param {Object} block - Block data
 * @returns {string} HTML representation
 */
function renderEmbedBlock(block) {
  const { url, caption, embedType } = block;

  let embedHtml;

  if (embedType === 'youtube') {
    // Extract YouTube video ID
    const videoId = extractYouTubeId(url);
    if (videoId) {
      embedHtml = `
        <div class="blockdoc-embed-container">
          <iframe 
            width="560" 
            height="315" 
            src="https://www.youtube.com/embed/${videoId}" 
            frameborder="0" 
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
            allowfullscreen>
          </iframe>
        </div>
      `;
    } else {
      embedHtml = '<p>Invalid YouTube URL</p>';
    }
  } else if (embedType === 'twitter') {
    embedHtml = `
      <div class="blockdoc-embed blockdoc-twitter">
        <blockquote class="twitter-tweet">
          <a href="${sanitizeHtml(url)}"></a>
        </blockquote>
        <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
      </div>
    `;
  } else {
    // Generic embed with iframe
    embedHtml = `
      <div class="blockdoc-embed">
        <iframe 
          src="${sanitizeHtml(url)}" 
          frameborder="0" 
          width="100%" 
          height="400"
          allowfullscreen>
        </iframe>
      </div>
    `;
  }

  if (caption) {
    embedHtml += `<figcaption class="blockdoc-caption">${sanitizeHtml(
      caption
    )}</figcaption>`;
    return `<figure class="blockdoc-figure">${embedHtml}</figure>`;
  }

  return embedHtml;
}

/**
 * Render a divider block
 * @returns {string} HTML representation
 */
function renderDividerBlock() {
  return '<hr class="blockdoc-divider" />';
}

/**
 * Extract YouTube video ID from URL
 * @param {string} url - YouTube URL
 * @returns {string|null} YouTube video ID or null if invalid
 */
function extractYouTubeId(url) {
  try {
    const parsedUrl = new URL(url);

    // Handle youtu.be format
    if (parsedUrl.hostname === 'youtu.be') {
      return parsedUrl.pathname.slice(1);
    }

    // Handle youtube.com format
    if (
      parsedUrl.hostname === 'www.youtube.com' ||
      parsedUrl.hostname === 'youtube.com'
    ) {
      const params = new URLSearchParams(parsedUrl.search);
      return params.get('v');
    }

    return null;
  } catch (e) {
    return null;
  }
}
</file>

<file path="src/renderers/markdown.js">
/**
 * BlockDoc Markdown Renderer
 *
 * Converts BlockDoc documents to Markdown
 */

/**
 * Render a BlockDoc document to Markdown
 * @param {Object} article - The article object from a BlockDoc document
 * @returns {string} Markdown representation
 */
export function renderToMarkdown(article) {
  if (!article || !article.blocks || !Array.isArray(article.blocks)) {
    throw new Error('Invalid article structure');
  }

  const markdown = [
    `# ${article.title}`,
    ''
  ];

  // Add metadata if present
  if (article.metadata) {
    if (article.metadata.author) {
      markdown.push(`> Author: ${article.metadata.author}`);
    }
    
    if (article.metadata.publishedDate) {
      const date = new Date(article.metadata.publishedDate);
      markdown.push(`> Published: ${date.toDateString()}`);
    }
    
    if (article.metadata.tags && Array.isArray(article.metadata.tags) && article.metadata.tags.length > 0) {
      markdown.push(`> Tags: ${article.metadata.tags.join(', ')}`);
    }
    
    markdown.push('');
  }

  // Render each block
  article.blocks.forEach((block) => {
    markdown.push(renderBlockToMarkdown(block));
    markdown.push(''); // Add a blank line after each block
  });

  return markdown.join('\n');
}

/**
 * Render a single block to Markdown
 * @param {Object} block - Block data
 * @returns {string} Markdown representation of the block
 */
function renderBlockToMarkdown(block) {
  const { type } = block;

  switch (type) {
  case 'text':
    return renderTextBlockToMarkdown(block);
  case 'heading':
    return renderHeadingBlockToMarkdown(block);
  case 'image':
    return renderImageBlockToMarkdown(block);
  case 'code':
    return renderCodeBlockToMarkdown(block);
  case 'list':
    return renderListBlockToMarkdown(block);
  case 'quote':
    return renderQuoteBlockToMarkdown(block);
  case 'embed':
    return renderEmbedBlockToMarkdown(block);
  case 'divider':
    return '---';
  default:
    return `[Unknown block type: ${type}]`;
  }
}

/**
 * Render a text block to Markdown
 * @param {Object} block - Block data
 * @returns {string} Markdown representation
 */
function renderTextBlockToMarkdown(block) {
  // Text content is already in markdown format
  return block.content;
}

/**
 * Render a heading block to Markdown
 * @param {Object} block - Block data
 * @returns {string} Markdown representation
 */
function renderHeadingBlockToMarkdown(block) {
  const { level, content } = block;
  const validLevel = Math.min(Math.max(parseInt(level) || 2, 1), 6);
  const hashtags = '#'.repeat(validLevel);
  
  return `${hashtags} ${content}`;
}

/**
 * Render an image block to Markdown
 * @param {Object} block - Block data
 * @returns {string} Markdown representation
 */
function renderImageBlockToMarkdown(block) {
  const { url, alt, caption } = block;
  
  let markdown = `![${alt || ''}](${url})`;
  
  if (caption) {
    markdown += `\n*${caption}*`;
  }
  
  return markdown;
}

/**
 * Render a code block to Markdown
 * @param {Object} block - Block data
 * @returns {string} Markdown representation
 */
function renderCodeBlockToMarkdown(block) {
  const { language, content } = block;
  
  return '```' + (language || '') + '\n' + content + '\n```';
}

/**
 * Render a list block to Markdown
 * @param {Object} block - Block data
 * @returns {string} Markdown representation
 */
function renderListBlockToMarkdown(block) {
  const { items, listType } = block;
  
  if (!items || !Array.isArray(items)) {
    return '[Invalid list items]';
  }
  
  return items.map((item, index) => {
    if (listType === 'ordered') {
      return `${index + 1}. ${item}`;
    } else {
      return `- ${item}`;
    }
  }).join('\n');
}

/**
 * Render a quote block to Markdown
 * @param {Object} block - Block data
 * @returns {string} Markdown representation
 */
function renderQuoteBlockToMarkdown(block) {
  const { content, attribution } = block;
  
  let markdown = content.split('\n').map(line => `> ${line}`).join('\n');
  
  if (attribution) {
    markdown += `\n>\n>  ${attribution}`;
  }
  
  return markdown;
}

/**
 * Render an embed block to Markdown
 * @param {Object} block - Block data
 * @returns {string} Markdown representation
 */
function renderEmbedBlockToMarkdown(block) {
  const { url, caption, embedType } = block;
  
  let markdown = `[${embedType || 'Embedded content'}: ${url}](${url})`;
  
  if (caption) {
    markdown += `\n*${caption}*`;
  }
  
  return markdown;
}
</file>

<file path="src/index.js">
/**
 * BlockDoc
 * 
 * Main entry point for the BlockDoc library
 */

// Core classes
export { Block } from './core/block.js';
export { BlockDocDocument } from './core/document.js';

// Renderers
export { renderToHTML } from './renderers/html.js';
export { renderToMarkdown } from './renderers/markdown.js';

// Schema
import { schema } from './schema-loader.js';
export { schema };

// Version
export const version = '1.0.0';
</file>

<file path="package.json">
{
  "name": "blockdoc",
  "version": "1.0.0",
  "description": "A simple, powerful standard for structured content that works beautifully with LLMs, humans, and modern editors",
  "type": "module",
  "main": "./dist/cjs/index.js",
  "module": "./dist/esm/index.js",
  "browser": "./dist/blockdoc.min.js",
  "exports": {
    ".": {
      "import": "./dist/esm/index.js",
      "require": "./dist/cjs/index.js",
      "browser": "./dist/blockdoc.min.js"
    },
    "./renderers/html": {
      "import": "./dist/esm/renderers/html.js",
      "require": "./dist/cjs/renderers/html.js"
    },
    "./renderers/markdown": {
      "import": "./dist/esm/renderers/markdown.js",
      "require": "./dist/cjs/renderers/markdown.js"
    },
    "./utils/sanitize": {
      "import": "./dist/esm/utils/sanitize.js",
      "require": "./dist/cjs/utils/sanitize.js"
    }
  },
  "files": [
    "dist",
    "src",
    "index.d.ts"
  ],
  "types": "index.d.ts",
  "scripts": {
    "test": "jest",
    "build": "npm run clean && npm run build:esm && npm run build:cjs && npm run build:umd",
    "build:esm": "rollup -c rollup.config.esm.js",
    "build:cjs": "rollup -c rollup.config.cjs.js",
    "build:umd": "rollup -c rollup.config.umd.js",
    "clean": "rimraf dist",
    "docs": "jsdoc -c jsdoc.json",
    "lint": "eslint src/**/*.js",
    "examples": "node examples/simple-blog/index.js",
    "prepublishOnly": "npm run lint && npm test && npm run build"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/berrydev-ai/blockdoc.git"
  },
  "keywords": [
    "content",
    "cms",
    "llm",
    "markdown",
    "structured-content",
    "editor",
    "blocks",
    "document",
    "ai"
  ],
  "author": "Eric Berry <eric@berrydev.ai>",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/berrydev-ai/blockdoc/issues"
  },
  "homepage": "https://github.com/berrydev-ai/blockdoc#readme",
  "dependencies": {
    "ajv": "^8.12.0",
    "ajv-formats": "^2.1.1",
    "highlight.js": "^11.8.0",
    "marked": "^9.1.0"
  },
  "devDependencies": {
    "@babel/core": "^7.23.2",
    "@babel/preset-env": "^7.23.2",
    "@rollup/plugin-babel": "^6.0.4",
    "@rollup/plugin-commonjs": "^25.0.5",
    "@rollup/plugin-json": "^6.0.1",
    "@rollup/plugin-node-resolve": "^15.2.3",
    "@rollup/plugin-terser": "^0.4.4",
    "core-js": "^3.32.2",
    "eslint": "^8.51.0",
    "jest": "^29.7.0",
    "jsdoc": "^4.0.2",
    "openai": "^4.12.1",
    "rimraf": "^5.0.5",
    "rollup": "^4.0.2"
  },
  "peerDependencies": {
    "openai": "^4.0.0"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}
</file>

<file path="README.md">
<picture>
  <source media="(prefers-color-scheme: dark)" srcset="assets/logo-wide-dark.png">
  <source media="(prefers-color-scheme: light)" srcset="assets/logo-wide-light.png">
  <img alt="blockdoc logo" src="logo-wide-light.png">
</picture>

A simple, powerful standard for structured content that works beautifully with LLMs, humans, and modern editors.

[![npm version](https://img.shields.io/npm/v/blockdoc.svg)](https://www.npmjs.com/package/blockdoc)
[![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](https://opensource.org/licenses/MIT)

## Why blockdoc?

blockdoc provides a lightweight, flexible format for structured content that is:

- **LLM-friendly**: Optimized for AI generation and targeted modifications
- **Simple**: Flat structure with semantic IDs and minimal nesting
- **Extensible**: Core block types with room for custom extensions
- **Framework-agnostic**: Works with any frontend or backend technology
- **Database-ready**: Easy to store and query in SQL or NoSQL databases

## Core Concepts

BlockDoc is based on a block-based architecture where content is organized into discrete, individually addressable blocks. Each block has:

- A semantic ID (like 'intro', 'section-1')
- A block type ('text', 'heading', 'image', 'code')
- Content (in Markdown for text-based blocks)
- Optional metadata

This architecture enables:

- Targeted updates to specific sections
- Better organization of content
- Easy integration with LLMs
- Flexible rendering in different formats

### Core Block Types

1. **Text** - Standard paragraphs with Markdown support
2. **Heading** - Section headers with configurable levels
3. **Image** - Pictures with src, alt text, and optional caption
4. **Code** - Code blocks with syntax highlighting
5. **List** - Ordered or unordered lists
6. **Quote** - Blockquote content
7. **Embed** - Embedded content (videos, social media posts)
8. **Divider** - Horizontal rule/separator

### Design Principles

1. **Simplicity**: Minimal structure with only necessary properties
2. **LLM-Friendly**: Optimized for AI content generation and modification
3. **Human-Editable**: Clear, readable format for direct editing
4. **Database-Ready**: Easily stored in SQL or NoSQL databases
5. **Extensible**: Core types with support for custom block types
6. **Semantic**: Meaningful IDs for blocks rather than auto-generated IDs
7. **Portable**: Framework-agnostic with multiple render targets

```json
{
  "article": {
    "title": "Getting Started with blockdoc",
    "blocks": [
      {
        "id": "intro",
        "type": "text",
        "content": "blockdoc makes structured content **simple**."
      },
      {
        "id": "first-steps",
        "type": "heading",
        "level": 2,
        "content": "First Steps"
      },
      {
        "id": "step-one",
        "type": "text",
        "content": "Install blockdoc using npm: `npm install blockdoc`"
      }
    ]
  }
}
```

## Installation

Install BlockDoc from npm:

```bash
# Using npm
npm install blockdoc

# Using yarn
yarn add blockdoc

# Using pnpm
pnpm add blockdoc
```

## Usage

BlockDoc supports multiple import formats:

### ESM (ES Modules)

```javascript
import { BlockDocDocument, Block } from "blockdoc"

// Create a new document
const doc = new BlockDocDocument({
  title: "My First BlockDoc Post",
})

// Add blocks using factory methods
doc.addBlock(Block.text("intro", "Welcome to my first post!"))

// Render to HTML
const html = doc.renderToHTML()
console.log(html)
```

### CommonJS

```javascript
const { BlockDocDocument, Block } = require("blockdoc")

// Create a new document
const doc = new BlockDocDocument({
  title: "My First BlockDoc Post",
})

// Add blocks
doc.addBlock(Block.text("intro", "Welcome to my first post!"))

// Render to HTML
const html = doc.renderToHTML()
console.log(html)
```

### Browser (UMD)

```html
<script src="https://unpkg.com/blockdoc/dist/blockdoc.min.js"></script>
<script>
  // BlockDoc is available as a global variable
  const doc = new BlockDoc.BlockDocDocument({
    title: "My First BlockDoc Post",
  })

  doc.addBlock(BlockDoc.Block.text("intro", "Welcome to my first post!"))

  // Render to HTML
  const html = doc.renderToHTML()
  document.getElementById("content").innerHTML = html
</script>
```

### TypeScript Support

BlockDoc includes TypeScript type definitions:

```typescript
import { BlockDocDocument, Block, BlockData } from "blockdoc"

// Create a typed document
const doc = new BlockDocDocument({
  title: "My First BlockDoc Post",
  metadata: {
    author: "John Doe",
    publishedDate: new Date().toISOString(),
  },
})

// Add blocks with proper typing
doc.addBlock(Block.text("intro", "Welcome to my first post!"))
```

## Working with LLMs

blockdoc shines when generating or modifying content with LLMs:

```javascript
import { blockdocDocument } from "blockdoc"
import { OpenAI } from "openai"

const openai = new OpenAI()

// Update a specific section using an LLM
async function updateSection(document, blockId, prompt) {
  const block = document.getBlock(blockId)

  const response = await openai.chat.completions.create({
    model: "gpt-4",
    messages: [
      {
        role: "system",
        content: `Update the following content to ${prompt}. Return only the updated content.`,
      },
      {
        role: "user",
        content: block.content,
      },
    ],
  })

  document.updateBlock(blockId, {
    content: response.choices[0].message.content,
  })

  return document
}
```

## Documentation

- [Full Specification](docs/spec/blockdoc-specification.md)
- [API Reference](docs/api-docs/)
- [Tutorials](docs/tutorials/)
  - [Getting Started](docs/tutorials/getting-started.md)
  - [Block Types](docs/tutorials/block-types.md)
  - [LLM Integration](docs/tutorials/llm-integration.md)
- [Examples](examples/README.md)
  - [Simple Blog](examples/simple-blog/)
  - [React Demo](examples/react-demo/)
  - [LLM Integration](examples/llm-integration/)

## Development

### Installation

```bash
# Clone the repository
git clone https://github.com/yourusername/blockdoc.git
cd blockdoc

# Install dependencies
npm install
```

### Testing

BlockDoc uses Jest for testing. To run the tests:

```bash
# Run tests
npm test

# Run tests with coverage report
npm test -- --coverage
```

Current test coverage: 97%+ statement coverage across all components.

## Contributing

We welcome contributions! See [CONTRIBUTING.md](CONTRIBUTING.md) for details on how to contribute, including our testing guidelines.

## License

MIT
</file>

</files>
